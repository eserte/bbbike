#!/usr/bin/perl
# -*- perl -*-

#
# $Id: cmdbbbike,v 4.6 2003/01/08 20:10:37 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2001 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://bbbike.sourceforge.net
#

package BBBikeRouting::Cmdline;
use FindBin;
use lib ($FindBin::RealBin, "$FindBin::RealBin/lib");
use BBBikeRouting;
@ISA = 'BBBikeRouting';
use strict;

sub cmdline_input {
    my $self = shift;

    if (eval { require Getopt::Long; 1 }) {
	if (!Getopt::Long::GetOptions
	    ("vehicle=s" => sub { $self->Context->Vehicle($_[1]) },
	     "algorithm=s" => sub { $self->Context->Algorithm($_[1]) },
	     "xs!" => sub { $self->Context->UseXS($_[1]) },
	     "cache!" => sub { $self->Context->UseCache($_[1]) },
	     "scope=s" => sub { $self->Context->Scope($_[1]) },
	     "v" => sub { require Strassen; Strassen::set_verbose(1);
			  $self->Context->Verbose(1),
		      },
	    )) {
	    die "Usage: $0 [-vehicle vehicle] [-[no]cache] [-[no]xs]
        [-algorithm ...] [-scope ...] [-v] start goal

start and goal may be prefixed with \"city:\" to force cities instead of
streets.
";
	}
    } else {
	warn "No Getopt::Long installed...\n";
    }

    if (@ARGV < 2) {
	print "Zu wenige Argumente: mindestens Start- und Zielstraße angeben!\n";
	exit 1;
    }
    if (@ARGV == 2) {
	set_city_or_street($self->Start, $ARGV[0]);
	set_city_or_street($self->Goal,  $ARGV[1]);
    } elsif (@ARGV == 4) {
	$self->Start->Street  ($ARGV[0]);
	$self->Start->Citypart($ARGV[1]);
	$self->Goal->Street   ($ARGV[2]);
	$self->Goal->Citypart ($ARGV[3]);
    } elsif (@ARGV == 3) {
	set_city_or_street($self->Start, shift @ARGV);
	if ($ARGV[0] =~ /^\d+$/) {
	    $self->Start->Citypart(shift @ARGV);
	} elsif ($ARGV[1] =~ /^\d+$/) {
	    $self->Goal->Citypart(pop @ARGV);
	}
	if (@ARGV == 1) {
	    set_city_or_street($self->Goal, shift @ARGV);
	} else {
	    require Geography;
	    my $geo = Geography->new('Berlin', 'DE');
	    $ENV{LANG} = "de";
	    my(@cityparts) = keys %{ $geo->subcitypart_to_citypart };
	    foreach (@cityparts) {
		if ($_ =~ /^\Q$ARGV[0]\E/i) {
		    $self->Start->Citypart ($ARGV[0]);
		    set_city_or_street($self->Goal, $ARGV[1]);
		    last;
		} elsif ($_ =~ /^\Q$ARGV[1]\E/i) {
		    set_city_or_street($self->Goal, $ARGV[0]);
		    $self->Goal->Citypart($ARGV[1]);
		    last;
		}
	    }
	    if (!$self->Goal->Street && !$self->Goal->City) {
		set_city_or_street($self->Goal, $ARGV[0]);
		$self->Goal->Citypart($ARGV[1]);
	    }
	}
    }
}

sub cmdline_output {
    my $self = shift;

    print $self->Start->Street;
#XXX
#      if ($multi_from) {
#  	print " ($from_citypart)";
#      }
    print " - ";
    print $self->Goal->Street;
#      if ($multi_to) {
#  	print " ($to_citypart)";
#      }
    print "\n";

    print
	join("\n", map { sprintf("%-40s %s", $_->{Street}, $_->{Whole}) }
	               @{ $self->RouteInfo} ), "\n";
}

sub set_city_or_street {
    my($o, $s) = @_;
    if ($s =~ /^(?:city|ort):(.*)$/) {
	$o->City($1);
	$o->Street(undef);
    } else {
	$o->Street($s);
    }
}

return 1 if caller() or keys %Devel::Trace::; # XXX Tracer bug

######################################################################

package main;

my $routing = BBBikeRouting->new->init_context;
bless $routing, 'BBBikeRouting::Cmdline'; # 5.005 compat

$routing->cmdline_input();
$routing->search();
$routing->cmdline_output();

__END__
