#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2009,2010 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	);

use Fcntl qw(SEEK_SET);
use File::Temp qw(tempfile);
use Getopt::Long;
use Karte::Polar;
use Karte::Standard;
use Strassen::Core;
use Strassen::Strasse;
use VectorUtil qw(get_polygon_center);

sub usage () {
    die <<EOF;
usage: $0 [-ignore-missing] [-use-orig] [-quiet] [-debug] [datadir]
       $0 [-type area|waterway|highway|railway|ferry] -single bbdfile

Either convert a whole bbbike data directory, or convert a single bbd
file.
EOF
}

my $single_file;
my $single_file_type;
my $fragezeichen_file;
my $ignore_missing;
my $use_orig;
my $shorten_for_garmin;
my $quiet;
my $debug;
GetOptions("single=s" => \$single_file,
	   "type=s" => \$single_file_type,
	   "fragezeichen=s" => \$fragezeichen_file,
	   "ignore-missing!" => \$ignore_missing,
	   "use-orig!" => \$use_orig,
	   "shorten-for-garmin!" => \$shorten_for_garmin,
	   "quiet!" => \$quiet,
	   "debug!" => \$debug,
	  )
    or usage;

my $datadir;
if (!$single_file) {
    $single_file_type and usage;
    $datadir = shift || "$FindBin::RealBin/../data";
} else {
    @ARGV and usage;
}

######################################################################
# Max. length on Garmin devices (at least etrex vista hcx) is 151
use constant MAX_LABEL_LENGTH => 151;
use constant MAX_ABBREV_LEVEL => 4;
my %ABBREV_WORD_DEFS = ( 'Uhr' => 'h',
			 'und' => '&',
			 'Montag' => 'Mo',
			 'montags' => 'mo',
			 'Freitag' => 'Fr',
			 'freitags' => 'fr',
			 'Samstag' => 'Sa',
			 'Sonntag' => 'So',
			 'pro Person' => 'p.P.',
			 'Euro' => "\x{20ac}",
			 'EUR' => "\x{20ac}",
			 'bis' => '-',
			 'stündlich' => 'stündl.',
			 'täglich' => 'tägl.',
			 'Minuten' => 'Min',
			 'April' => 'Apr',
			 'August' => 'Aug',
			 'Oktober' => 'Okt',
			 'Fahrzeit' => 'Fahrzt.',
		       );
my $ABBREV_WORD_RX = '(' . join("|", map { '\b'.quotemeta($_).'\b' } keys %ABBREV_WORD_DEFS) . ')';
$ABBREV_WORD_RX = qr{$ABBREV_WORD_RX};
######################################################################

my($nodefh, $nodefile) = tempfile(UNLINK => 1, SUFFIX => "_node.xml");
binmode $nodefh, ':utf8';
my($wayfh, $wayfile) = tempfile(UNLINK => 1, SUFFIX => "_way.xml");
binmode $wayfh, ':utf8';

my $next_node_id = 1;
my $next_way_id = 1;
my %node_id;

my %oneway;
my %no_access;
my %speed0;
my @remember_quality;

my %cat_to_highway = ('B'  => 'primary',
		      'HH' => 'primary',
		      'H'  => 'secondary',
		      'NH' => 'tertiary',
		      'N'  => 'residential',
		      'NN' => 'cycleway', # XXX
		     );

my %cat_to_railway = ('U' => 'subway',
		      'S' => 'light_rail',
		      'R' => 'rail',
		     );

my %cat_to_area_landuse = ('Forest'     => 'forest',
			   'Cemetery'   => 'cemetery',
			   'Industrial' => 'industrial',
			   # 'Ae' => 'airport', # does not exist
			   'Orchard'    => 'allotments',
			   'Sport'      => 'sports',
			   'Green'      => 'village_green',
			  );
my %cat_to_area_leisure = ('P'          => 'park',
			   'Pabove'     => 'park',
			  );

my($min_lat, $max_lat, $min_lon, $max_lon);

if ($single_file) {
    $single_file_type ||= 'highway';
    my $subname = 'handle_' . $single_file_type . '_like';
    no strict 'refs';
    if (!defined &{$subname}) {
	die "Invalid type $single_file_type, no callback function exists for that.\n";
    }
    my $sub = \&{$subname};
    Strassen->new_stream($single_file)->read_stream($sub);
} else {
    # NODE-like
    do_file("$datadir/ampeln", \&handle_trafficsignals_like);
    if (-r "$datadir/zebrastreifen") { # path for osm data
	do_file("$datadir/zebrastreifen", \&handle_zebrastreifen_like);
    } elsif (-r "$datadir/../misc/zebrastreifen") { # path for bbbike data (will be moved some day XXX)
	do_file("$datadir/../misc/zebrastreifen", \&handle_zebrastreifen_like);
    }
    do_file("$datadir/ubahnhof", \&handle_railway_stations_like);
    do_file("$datadir/sbahnhof", \&handle_railway_stations_like);
    do_file("$datadir/rbahnhof", \&handle_railway_stations_like);
    do_file("$datadir/gesperrt", \&handle_blocked_node_like);

    do_file("$datadir/orte", \&handle_city_like);
    do_file("$datadir/orte2", \&handle_city_like);
    do_file("$datadir/ortsschilder", \&handle_city_limit_like);
    do_file("$datadir/berlin_ortsteile", \&handle_berlin_citypart_like);

    do_file("$datadir/comments_ferry", \&handle_ferry_info_like);

    # WAY-like
    do_file("$datadir/gesperrt", \&handle_blocked_way_like);
    do_file("$datadir/handicap_s", \&handle_handicap_like);
    do_file("$datadir/handicap_l", \&handle_handicap_like);
    do_file("$datadir/qualitaet_s", \&handle_handicap_like);
    do_file("$datadir/qualitaet_l", \&handle_handicap_like);

    do_file("$datadir/flaechen", \&handle_area_like);

    do_file("$datadir/wasserstrassen", \&handle_waterway_like);
    do_file("$datadir/wasserumland", \&handle_waterway_like);
    do_file("$datadir/wasserumland2", \&handle_waterway_like);

    do_file("$datadir/faehren", \&handle_ferry_like);

    do_file("$datadir/strassen", \&handle_berlin_highway_like);
    do_file("$datadir/landstrassen", \&handle_anywhere_highway_like);
    do_file("$datadir/landstrassen2", \&handle_anywhere_highway_like);

    dump_quality();
	
    if (!$fragezeichen_file) {
	$fragezeichen_file = -r "$datadir/../tmp/fragezeichen-nextcheck.bbd" ? "$datadir/../tmp/fragezeichen-nextcheck.bbd" : "$datadir/fragezeichen";
    }
    do_file($fragezeichen_file, \&handle_fixme_like);

    do_file("$datadir/ubahn", \&handle_railway_like);
    do_file("$datadir/sbahn", \&handle_railway_like);
    do_file("$datadir/rbahn", \&handle_railway_like);

    # Use -orig files here, because it has more information (RW? etc.)
    if (-r "$datadir/radwege-orig") {
	do_file("$datadir/radwege-orig", \&handle_cycleway_like);
    }
    if (-r "$datadir/comments_cyclepath-orig") {
	do_file("$datadir/comments_cyclepath-orig", \&handle_cycleway_like);
    }
}

sub do_file {
    my($file, $cb) = @_;
    $file .= "-orig" if $use_orig;
    eval {
	Strassen->new_stream($file)->read_stream($cb);
    };
    if ($@) {
	if ($ignore_missing) {
	    warn "Cannot find or handle $file, skipping..\n" unless $quiet;
	} else {
	    die $@;
	}
    }
}

sub handle_blocked_node_like {
    my($r, $dir) = @_;
    my($cat) = $r->[Strassen::CAT] =~ m{^([^:]+)};
    my $attribs;
    if ($cat eq 'BNP') {
	if ($r->[Strassen::NAME] =~ m{drängelgitter}i) {
	    $attribs = { barrier => 'cycle_barrier' };
	} else {
	    $attribs = { barrier => 'bollard' }; #  (which is a quite bold assumption)
	}
    } elsif ($cat eq '0') {
	if ($r->[Strassen::NAME] =~ m{(\d+)\s+Stufe}) { # XXX see steps_stats.pl for more possible regexps, should go into a module!
	    $attribs->{step_count} = $1;
	}
	$attribs->{highway} = 'steps'; # not good: steps are in osm usually lines, not nodes!
    }
    if ($attribs) {
	get_node_ids($r, $attribs); # as a side-effect, create the nodes
    }
}

sub handle_blocked_way_like {
    my($r, $dir) = @_;
    my($cat) = $r->[Strassen::CAT] =~ m{^([^:]+)};
    my @node_ids = map {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	my $node_id = maybe_add_node($px,$py);
	$node_id;
    } @{ $r->[Strassen::COORDS] };
    for my $node_id_i (1 .. $#node_ids) {
	if ($cat eq '1') {
	    $oneway{$node_ids[$node_id_i].' '.$node_ids[$node_id_i-1]} = 1; # in osm oneway is the open direction, not the closed
	} elsif ($cat eq '2') {
	    $no_access{$node_ids[$node_id_i-1].' '.$node_ids[$node_id_i]} = 1;
	    $no_access{$node_ids[$node_id_i].' '.$node_ids[$node_id_i-1]} = 1;
	}
    }
}

sub handle_handicap_like {
    my($r, $dir) = @_;
    my($cat_hin, $cat_rueck);
    if ($r->[Strassen::CAT] =~ /^(.*);(.*)$/) {
	($cat_hin, $cat_rueck) = ($1, $2);
    } else {
	($cat_hin, $cat_rueck) = ($r->[Strassen::CAT], $r->[Strassen::CAT]);
    }
    for ($cat_hin, $cat_rueck) {
	if (defined $_) {
	    ($_) = $_ =~ m{^([^:]+)};
	}
    }
    my @node_ids = map {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	my $node_id = maybe_add_node($px,$py);
	$node_id;
    } @{ $r->[Strassen::COORDS] };
    for my $node_id_i (1 .. $#node_ids) {
	if ($cat_hin =~ m{^[qQ][34]$}) {
	    $speed0{$node_ids[$node_id_i-1].' '.$node_ids[$node_id_i]} = 1; # XXX correct direction
	}
	if (defined $cat_rueck) {
	    if ($cat_rueck =~ m{^[qQ][34]$}) {
		$speed0{$node_ids[$node_id_i].' '.$node_ids[$node_id_i-1]} = 1;
	    }
	}
    }

    my($quality_hin) = $cat_hin =~ m{^Q(\d+)}; # XXX maybe support for +/-?
    my $quality = $quality_hin;
    if (defined $cat_rueck) {
	my($quality_rueck) = $cat_rueck =~ m{^Q(\d+)}; # XXX maybe support for +/-?
	if (defined $quality_rueck && (!defined $quality_hin || $quality_rueck > $quality_hin)) {
	    $quality = $quality_rueck;
	}
    }
    if (defined $quality) {
	push @remember_quality, [\@node_ids, $quality];
    }
}

sub handle_berlin_highway_like   { _handle_highway_like('Berlin', @_) }
sub handle_anywhere_highway_like { _handle_highway_like(undef, @_) }

sub _handle_highway_like {
    my($city, $r, $dir) = @_;

    my($cat) = $r->[Strassen::CAT] =~ m{^([^:]+)};
    if ($cat eq 'Pl') {
	# XXX maybe handle later...
	return;
    }
    my $highway_tag = $cat_to_highway{$cat};
    if (!defined $highway_tag) {
	warn "Ignore cat='$r->[Strassen::CAT]'...\n";
	return;
    }

    my @node_ids = get_node_ids($r);

    # split streets
    my @segments;
    my $last_tags;
    my @last_tags;
    my $begin_split_index = 0;
    for my $node_idx (1 .. $#node_ids) {
	my $forward_spec = $node_ids[$node_idx-1].' '.$node_ids[$node_idx];
	my $backward_spec = $node_ids[$node_idx].' '.$node_ids[$node_idx-1];
	my @this_tags = (
			 ($oneway{$forward_spec}||''),
			 ($oneway{$backward_spec}||''),
			 ($no_access{$forward_spec}||''),
			 ($speed0{$forward_spec}||''),
			 ($speed0{$backward_spec}||''),
			);
	my $this_tags = join(" ", @this_tags);
	if (defined $last_tags) {
	    if ($last_tags ne $this_tags) {
		# we need to split
		push @segments, [[@node_ids[$begin_split_index..$node_idx-1]], [@last_tags]];
		$begin_split_index = $node_idx-1;
		$last_tags = $this_tags;
		@last_tags = @this_tags;
	    }
	} else {
	    $last_tags = $this_tags;
	    @last_tags = @this_tags;
	}
    }
    push @segments, [[@node_ids[$begin_split_index..$#node_ids]], [@last_tags]];

    my($name, @cityparts) = Strasse::split_street_citypart($r->[Strassen::NAME]);
    _xmlify($name);

    # This is the most reasonable scheme to set is_in/addr tags, to
    # get it best working in the "Find" screen of Garmin:
    #
    # for streets in Berlin (defined $city):
    # * is_in:county => "Berlin"
    # * addr:city => first citypart (if any)
    #
    # for streets outside Berlin (@cityparts exist)
    # * addr:city => first citypart (usually there is exactly one)
    #
    # If any of these tags is set, then also set addr:country
    my %is_in;
    if (defined $city) {
	$is_in{'is_in:county'} = $city; # XXX lying for Berlin, so we have cityparts in addr:city and Berlin in is_in:county
	if (@cityparts) {
	    $is_in{'addr:city'} = $cityparts[0];
	}
    } else {
	if (@cityparts) {
	    $is_in{'addr:city'} = $cityparts[0];
	}
    }
    if (%is_in) {
	$is_in{'addr:country'} = 'DE'; # XXX not always true, some streets are in Poland and Czech Republic
    }

    for my $segment (@segments) {
	my @node_ids = @{$segment->[0]};
	my($oneway, $oneway_reversed, $no_access, $speed0, $speed0_reversed) = @{$segment->[1]};

	if ($oneway_reversed) {
	    @node_ids = reverse @node_ids;
	    $oneway = 1;
	}

	my $any_speed0 = $speed0 || $speed0_reversed; # XXX for the real thing I had to split the way into two directions...
	    
	print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	for my $node_id (@node_ids) {
	    print $wayfh qq{  <nd ref="$node_id"/>\n};
	}
	print $wayfh qq{  <tag k="name" v="$name" />\n};
	while(my($k,$v) = each %is_in) {
	    _xmlify($v);
	    print $wayfh qq{  <tag k="$k" v="$v" />\n};
	}
	if ($any_speed0) {
	    print $wayfh qq{  <tag k="highway" v="footway" />\n};
	    print $wayfh qq{  <tag k="bicycle" v="yes" />\n};
	} else {
	    print $wayfh qq{  <tag k="highway" v="$highway_tag" />\n};
	}
	if ($oneway) {
	    print $wayfh qq{  <tag k="oneway" v="yes" />\n};
	}
	if ($no_access) {
	    print $wayfh qq{  <tag k="access" v="no" />\n};
	    print $wayfh qq{  <tag k="bicycle" v="no" />\n}; # access=no is not enough
	}

	if (0) {
	    print $wayfh qq{  <tag k="addr:street" v="$name" />\n};
	    print $wayfh qq{  <tag k="addr:housenumber" v="0" />\n}; # XXX pure faked
	    print $wayfh qq{  <tag k="addr:country" v="DE" />\n};
	    if (@cityparts) {
		# parse street numbers out
		@cityparts = grep {
		    my($type, $nr) = Strasse::parse_street_type_nr($_);
		    !defined $type;
		} @cityparts;
		if (@cityparts) {
		    _xmlify($cityparts[0]);
		    # XXX hack: use only first
		    print $wayfh qq{  <tag k="addr:city" v="$cityparts[0]" />\n};
		}
	    }
	}

	print $wayfh qq{</way>\n};
	$next_way_id++;
    }
}

sub handle_fixme_like {
    my($r, $dir) = @_;

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME] || 'FIXME';
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="FIXME" v="$name" />\n};
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_railway_like {
    my($r, $dir) = @_;

    my($cat) = $r->[Strassen::CAT] =~ m{^([^:]+)};
    return if $cat !~ m{^([USR])[ABC]?$};
    my $railway_cat = $cat_to_railway{$1};
    return if !defined $cat;

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    print $wayfh qq{  <tag k="railway" v="$railway_cat" />\n};
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_waterway_like {
    my($r, $dir) = @_;

    my($is_area, $cat);
    if ($r->[Strassen::CAT] =~ m{^F:([^:]+)}) {
	$is_area = 1;
	$cat = $1;
    } else {
	$cat = $r->[Strassen::CAT] =~ m{^([^:]+)};
    }
    # XXX handling W0,W1 etc. missing

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    if ($is_area) {
	print $wayfh qq{  <tag k="natural" v="water" />\n};
    } else {
	print $wayfh qq{  <tag k="waterway" v="river" />\n};
    }
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_ferry_like {
    my($r, $dir) = @_;

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    print $wayfh qq{  <tag k="route" v="ferry" />\n};
    # XXX description from comments_ferry missing
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_ferry_info_like {
    my($r, $dir) = @_;

    my $label = shorten_label($r->[Strassen::NAME]);

    get_node_id_from_center($r, { note => $label });
}

sub handle_area_like {
    my($r, $dir) = @_;

    if ($r->[Strassen::CAT] !~ m{^F:([^:]+)}) {
	return; # should never happen
    }
    my $cat = $1;
    my($landuse, $leisure);
    $landuse = $cat_to_area_landuse{$cat};
    if (!defined $landuse) {
	$leisure = $cat_to_area_leisure{$cat};
	if (!defined $leisure) {
	    #warn "Ignoring $cat...\n";
	    return;
	}
    }

    my @node_ids = get_node_ids($r);

    my $name = $r->[Strassen::NAME];
    _xmlify($name);

    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
    for my $node_id (@node_ids) {
	print $wayfh qq{  <nd ref="$node_id"/>\n};
    }
    print $wayfh qq{  <tag k="name" v="$name" />\n} if defined $name && length $name;
    if (defined $landuse) {
	print $wayfh qq{  <tag k="landuse" v="$landuse" />\n};
    } else {
	print $wayfh qq{  <tag k="leisure" v="$leisure" />\n};
    }
    print $wayfh qq{</way>\n};
    $next_way_id++;
}

sub handle_trafficsignals_like {
    my($r, $dir) = @_;

    my $attribs;
    if      ($r->[Strassen::CAT] =~ m{^X}) {
	$attribs = { highway => 'traffic_signals' };
    } elsif ($r->[Strassen::CAT] =~ m{^F}) {
	$attribs = { highway => 'crossing', crossing => 'traffic_signals' };
    } elsif ($r->[Strassen::CAT] =~ m{^B}) {
	$attribs = { railway => 'level_crossing' };
    } else {
	# ignore
	return;
    }

    get_node_ids($r, $attribs); # as a side-effect, create the nodes
}

sub handle_zebrastreifen_like {
    my($r) = @_;
    get_node_ids($r, { highway => 'crossing',
		       crossing => 'uncontrolled',
		       crossing_ref => 'zebra',
		     });
}

sub handle_railway_stations_like {
    my($r) = @_;
    my $is_ubahn = $r->[Strassen::CAT] =~ m{^U};
    my $is_sbahn = $r->[Strassen::CAT] =~ m{^S};
    my $attribs = { railway => 'station', # no distinction between halt and station
		    name => ($is_ubahn ? 'U ' : $is_sbahn ? 'S ' : '') . $r->[Strassen::NAME],
		  };
    if      ($is_ubahn) {
	$attribs->{station} = 'subway';
    } elsif ($is_sbahn) {
	$attribs->{station} = 'light_rail';
    } elsif ($r->[Strassen::CAT] =~ m{^R}) {
	# Regional/Fernbahnhof
    } else {
	warn "Unhandled railway station-like category $r->[Strassen::CAT]\n";
	return;
    }

    get_node_ids($r, $attribs);
}

sub handle_city_like {
    my($r) = @_;
    my $cat = $r->[Strassen::CAT];
    my $place;
    if      ($cat >= 5) {
	$place = 'city';
    } elsif ($cat >= 3) {
	$place = 'town';
    } elsif ($cat >= 1) {
	$place = 'village';
    } else {
	$place = 'hamlet';
    }
    get_node_ids($r, { name  => format_place_label($r->[Strassen::NAME]),
		       place => $place,
		     });
}

sub handle_city_limit_like {
    my($r) = @_;
    my $attribs = { traffic_sign => 'city_limit',
		    name         => format_place_label($r->[Strassen::NAME]),
		  };
    get_node_ids($r, $attribs);
}

sub handle_berlin_citypart_like {
    my($r) = @_;
    my($sxy) = join ",", get_polygon_center(map { split/,/ } @{ $r->[Strassen::COORDS] });
    get_node_id($sxy, { place => 'suburb',
			name  => $r->[Strassen::NAME],
			'is_in:county' => 'Berlin',
			'addr:country' => 'DE',
		      });
    # And add Berlin:
    if ($r->[Strassen::NAME] eq 'Mitte') {
	get_node_id($sxy, { place => 'county', # XXX lying
			    name  => 'Berlin',
			    'addr:country' => 'DE',
			  });
    }
}

sub handle_cycleway_like {
    my($r, $dir) = @_;
    my($cat_hin, $cat_rueck);
    if ($r->[Strassen::CAT] =~ /^(.*);(.*)$/) {
	($cat_hin, $cat_rueck) = ($1, $2);
    } else {
	($cat_hin, $cat_rueck) = ($r->[Strassen::CAT], $r->[Strassen::CAT]);
    }
    for ($cat_hin, $cat_rueck) {
	if (defined $_) {
	    ($_) = $_ =~ m{^([^:]+)};
	}
    }
    my @node_ids = map {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $_));
	my $node_id = maybe_add_node($px,$py);
	$node_id;
    } @{ $r->[Strassen::COORDS] };

    my $extra_tags_for_dualdir = sub {
	my $extra_tags = '';
	my $hin_mandatory   = ($cat_hin||'') eq 'RW2';
	my $rueck_mandatory = ($cat_rueck||'') eq 'RW8';
	if ($hin_mandatory && $rueck_mandatory) {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mandatory" />\n};
	} elsif ($hin_mandatory || $rueck_mandatory) {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mixed" />\n};
	} elsif (!$hin_mandatory && !$rueck_mandatory) {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="optional" />\n};
	} else {
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="unknown" />\n};
	}
	$extra_tags;
    };

    for my $def ([$cat_hin, +1], [$cat_rueck, -1]) {
	my($cat, $direction) = @$def;
	next if !defined $cat || $cat eq '';
	my $extra_tags;
	# Check for Zweirichtungsradweg first
	if (($cat_hin||'') =~ m{^(RW|RW1|RW2|RW\?)$} && ($cat_rueck||'') =~ m{^(RW8|RW8\?|RW9|RW9\?)$}) {
	    if ($direction == +1) {
		$extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
		$extra_tags .= qq{  <tag k="bbbike:cycleway_type" v="dualdir" />\n};
		$extra_tags .= $extra_tags_for_dualdir->();
	    }
	} elsif (($cat_rueck||'') =~ m{^(RW|RW1|RW2|RW\?)$} && ($cat_hin||'') =~ m{^(RW8|RW8\?|RW9|RW9\?)$}) {
	    if ($direction == -1) {
		$extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
		$extra_tags .= qq{  <tag k="bbbike:cycleway_type" v="dualdir" />\n};
		$extra_tags .= $extra_tags_for_dualdir->();
	    }
	} elsif ($cat eq 'RW' || $cat eq 'RW?' || $cat eq 'RW8?') {
	    $extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="unknown" />\n};
	} elsif ($cat eq 'RW1' || $cat eq 'RW9') {
	    $extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="optional" />\n};
	} elsif ($cat eq 'RW2' || $cat eq 'RW8') {
	    $extra_tags .= qq{  <tag k="cycleway" v="track" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mandatory" />\n};
	} elsif ($cat eq 'RW3') {
	    $extra_tags .= qq{  <tag k="cycleway" v="lane" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="optional" />\n};
	} elsif ($cat eq 'RW4') {
	    $extra_tags .= qq{  <tag k="cycleway" v="lane" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="mandatory" />\n};
	} elsif ($cat eq 'RW4?') {
	    $extra_tags .= qq{  <tag k="cycleway" v="lane" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:usage" v="unknown" />\n};
	} elsif ($cat eq 'RW5') {
	    $extra_tags .= qq{  <tag k="psv" v="yes" />\n};
	    if ($r->[Strassen::NAME()] =~ m{(Busspur ist immer gültig|Busspur gilt immer)}) {
		$extra_tags .= qq{  <tag k="bbbike:times" v="always" />\n};
	    }
	} elsif ($cat eq 'RW5?') {
	    $extra_tags .= qq{  <tag k="psv" v="yes" />\n};
	    $extra_tags .= qq{  <tag k="bbbike:times" v="unknown" />\n};
	} elsif ($cat eq 'RW6') {
	    # living street XXX
	} elsif ($cat eq 'RW7') {
	    # Fahrradstraße XXX
	} elsif ($cat eq 'RW10') {
	    # Nebenfahrbahn XXX
	} elsif ($cat eq 'RW0') {
	    # kein Radweg
	} else {
	    warn "Unexpected category '$cat'...";
	}
	if ($extra_tags) {
	    print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	    my @node_ids = $direction == +1 ? @node_ids : reverse(@node_ids);
	    for my $node_id (@node_ids) {
		print $wayfh qq{  <nd ref="$node_id"/>\n};
	    }
	    my $name = $r->[Strassen::NAME];
	    if (defined $name && $name ne '') {
		_xmlify($name);
		print $wayfh qq{  <tag k="name" v="$name" />\n};
	    }
	    print $wayfh $extra_tags;
	    print $wayfh qq{</way>\n};
	    $next_way_id++;
	}
    }
}

seek $nodefh, 0, SEEK_SET
    or die $!;
seek $wayfh, 0, SEEK_SET
    or die $!;

binmode STDOUT, ':utf8';
print qq{<osm version="0.6" generator="bbd2osm">\n};
print qq{<bound box="$min_lat,$min_lon,$max_lat,$max_lon" origin="http://www.bbbike.de" />\n};
while(<$nodefh>) {
    print $_;
}
while(<$wayfh>) {
    print $_;
}
print qq{</osm>\n};

sub get_node_ids {
    my($r, $attribs) = @_;
    my @node_ids;
    for my $sxy (@{ $r->[Strassen::COORDS] }) {
	my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $sxy));
	my $this_node_id = maybe_add_node($px, $py, $attribs);
	push @node_ids, $this_node_id;
    }
    @node_ids;
}

sub get_node_id {
    my($sxy, $attribs) = @_;
    my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $sxy));
    maybe_add_node($px, $py, $attribs);
}

sub get_node_id_from_center {
    my($r, $attribs) = @_;
    my $c = $r->[Strassen::COORDS];
    my $sxy;
    if (@$c % 2 == 1) {
	$sxy = $c->[@$c/2];
    } else {
	my($x0,$y0) = split /,/, $c->[@$c/2 - 1];
	my($x1,$y1) = split /,/, $c->[@$c/2];
	$sxy = (($x1-$x0)/2+$x0) . ',' . (($y1-$y0)/2+$y0);
    }
    my($px,$py) = $Karte::Polar::obj->trim_accuracy($Karte::Polar::obj->standard2map(split /,/, $sxy));
    maybe_add_node($px, $py, $attribs);
}

sub maybe_add_node {
    my($px, $py, $attribs) = @_;
    my $pxy = $px.','.$py;
    my $this_node_id = $node_id{$pxy};
    if (!defined $this_node_id) {
	$this_node_id = $node_id{$pxy} = $next_node_id++;
	print $nodefh qq{<node id="$this_node_id" lat="$py" lon="$px" user="eserte" visible="true" };
	if ($attribs) {
	    print $nodefh qq{>\n};
	    while(my($k,$v) = each %$attribs) {
		_xmlify($k);
		_xmlify($v);
		print $nodefh qq{  <tag k="$k" v="$v"/>\n};
	    }
	    print $nodefh qq{</node>\n};
	} else {
	    print $nodefh qq{/>\n};
	}

	$min_lon = $px if !defined $min_lon || $min_lon > $px;
	$max_lon = $px if !defined $max_lon || $max_lon < $px;
	$min_lat = $py if !defined $min_lat || $min_lat > $py;
	$max_lat = $py if !defined $max_lat || $max_lat < $py;

    }
    $this_node_id;
}

sub _xmlify {
    $_[0] =~ s{&}{&#38;}g; # XXX hack to xml-ify
    $_[0] =~ s{"}{&#34;}g;
    $_[0] =~ s{<}{&#60;}g;
    $_[0] =~ s{>}{&#62;}g;
}

sub dump_quality {
    for my $def (@remember_quality) {
	my($node_ids, $quality) = @$def;
	print $wayfh qq{<way id="$next_way_id" visible="true">\n};
	for my $node_id (@$node_ids) {
	    print $wayfh qq{  <nd ref="$node_id"/>\n};
	}
	print $wayfh qq{  <tag k="bbbike:quality" v="Q$quality" />\n};
	print $wayfh qq{</way>\n};
	$next_way_id++;
    }
}

sub shorten_label {
    my $s = shift;
    if ($shorten_for_garmin) {
	my $abbrev_level = 1;
	while (length $s > MAX_LABEL_LENGTH) {
	    if ($abbrev_level > MAX_LABEL_LENGTH) {
		$s =~ s{$ABBREV_WORD_RX}{$ABBREV_WORD_DEFS{$1}}g;
		if (length $s > MAX_LABEL_LENGTH) {
		    warn "Label <$s> too long and may not be shortened further...\n" if $debug;
		}
		last;
	    }
	    $s = Strasse::short($s, $abbrev_level);
	    $abbrev_level++;
	}
    }
    $s;
}

sub format_place_label {
    my $s = shift;
    my($name, $add) = split /\|/, $s;
    $name . (defined $add ? ' ' . $add : '');
}

__END__

=head1 NAME

bbd2osm - generate osm files out of bbd files

=head1 SYNOPSIS

Convert a whole bbbike data directory. For the default data directory
use

    bbd2osm > out.osm

For a specified data directory use

    bbd2osm /path/to/datadir > out.osm

For a single bbd file use

    bbd2osm -single in.bbd -type ... > out.osm

Refer to the usage for allowed types.

=head1 TODO

Currently the way and node ids start at 1 and increment by one. This
means clashes are possible if these data and "real" osm is mixed.
Maybe I should check if the various osm tools can handle negative or
non-numeric ids, or if there's a private id range documented.

Implement handling of BNP:...

=head1 AUTHOR

Slaven Rezic

=cut
