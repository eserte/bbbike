#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: bbd2polish,v 1.21 2007/08/25 21:11:37 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2005 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

# Convert from a set of bbd files into polish format for cgpsmapper

# For cgpsmapper see http://gps.chrisb.org/en/download.htm

# Usage:
#  .../bbbike/miscsrc/bbd2polish              > /tmp/bbbike.mp
#  .../bbbike/miscsrc/bbd2polish -mapset brb  > /tmp/brb.mp
#  .../bbbike/miscsrc/bbd2polish -mapset wide > /tmp/wide.mp
#  .../bbbike/miscsrc/bbd2polish -mapset fragezeichen > /tmp/fragezeichen.mp
#
# And then use cgpsmapper to convert the mp files to img files
# Use sendmap to send the img files to the Garmin device.

# TODOs
# * make N and NN the same category
# * use thinner streets
# * optionally add bab (maybe a map of its own)
# * make configurable everything
# * create a "legend" map, which shows just all street etc. types

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	);
use Strassen::Core;
use Strassen::Strasse;
use Karte::Polar;
use Karte::Standard;
use Getopt::Long;

my $codepage; # eg. 1252
my $mapset = "b";
my $layer;
my $strcatqual;
if (!GetOptions("mapset=s" => \$mapset,
		"layer=s" => \$layer,
		"codepage=s" => \$codepage,
		"strcatqual!" => \$strcatqual, # combined street/quality layer
	       )) {
    die "usage: $0 [-mapset [ b | brb | wide ]";
}

die "NYI" if $strcatqual;

my $anyquality = qr{(?:-Q\d[+-]?)?};
my $base_id = 10000099; # XXX how to choose img id? is there a manual? or just increment?
my $name = {"b"    => "BBBike map",
	    "brb"  => "BBBike BRB map",
	    "wide" => "BBBike wide map",
	    "fragezeichen" => "BBBike Fragezeichen",
	   }->{$mapset};
my $id   = {"b"    => $base_id,
	    "brb"  => $base_id+1,
	    "wide" => $base_id+2,
	    "fragezeichen" => $base_id+3,
	   }->{$mapset};
die "Cannot set name and/or id for <$mapset>"
    if !defined $name || !defined $id;
my $levels = 5;
my $use_dictionary = 0;

my $out = "";
$out .= <<EOF;
[IMG ID]
ID=$id
Name=$name
EOF
if (!$codepage) {
    $out .= <<EOF;
LBLcoding=6
EOF
} else {
    $out .= <<EOF;
LBLcoding=9
Codepage=$codepage
EOF
}
$out .= <<EOF;
;; transparency is a bad idea, because the base map is not
;; turnable off, at least on etrex vista
; Transparent=Y
PreProcess=F
;TreSize=800
TreSize=3000
Elevation=m
Levels=@{[ $levels + 1 ]}
; with Pl, POI etc.
Level0=24
; with NN/N
Level1=22
; with H
Level2=20
; with HH/B
Level3=18
; with HH/B
Level4=16
; empty
Level5=14
Zoom0=1
Zoom1=2
Zoom2=3
Zoom3=4
Zoom4=5
Zoom5=6
[END-IMG ID]

EOF

if ($use_dictionary) {
    $out .= <<EOF;
[DICTIONARY]
;Since the default is to import all elements, it is not neccesary to define filters for layer 0
;RGN10 = POI
;Level0RGN10=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

Level1RGN10=111111111111111111111111111111100000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level2RGN10=111111111111111111111111111111100000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

;           0              1               2               3               4               5               6 
;           123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0

;RGN20 = POI with cities
;Level0RGN20=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN20=111111111100000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level2RGN20=111111110000000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level3RGN20=111111100000000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

;RGN40 = polyline
;Level0RGN40=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN40=111110001110010000011100111111101101101111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Level2RGN40=111000001110010000011100111111100100100111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Level3RGN40=110000001110010000011100111111100100100111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

;RGN80 = polygon
;Level0RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
[END-DICTIONARY]

;[DICTIONARY]
;;Level0RGN10=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
;[END-DICTIONARY]

EOF
}

my @files;
if (defined $layer) {
    @files = $layer;
} else {
    if ($mapset eq 'b') {
	@files = qw(strassen wasserstrassen flaechen sbahn sbahnhof ubahn ubahnhof berlin faehren kneipen);
	for my $i (0 .. $#files) {
	    if ($files[$i] eq 'strassen' && -r "$FindBin::RealBin/../tmp/non-faked-strassen") {
	        $files[$i] = "$FindBin::RealBin/../tmp/non-faked-strassen";
	        warn "Using non-faked-strassen instead of strassen...\n";
	    }
	}
    } elsif ($mapset eq 'brb') {
	@files = qw(orte landstrassen wasserumland rbahn rbahnhof potsdam);
    } elsif ($mapset eq 'wide') {
	@files = qw(orte2 landstrassen2 wasserumland2 deutschland);
    } elsif ($mapset eq 'fragezeichen') {
	@files = qw(fragezeichen);
    }
}

for my $file (@files) {
    print STDERR "$file...";
    my $s = Strassen->new($file);
    $s->init;
    while(1) {
	my $r = $s->next;
	my @c = @{ $r->[Strassen::COORDS] };
	last if !@c;

	convert_coords(\@c);

	my $name = convert_strname($r->[Strassen::NAME]);
	my $add;
	($name, $add) = split(/\|/, $name);
	$name = "" if !defined $name;

	if ($file =~ /landstrassen/) {
	    if ($name =~ /\S+\s-\s\S+/) {
		$name = "";
	    }
	} elsif ($file =~ /rbahnhof/) {
	    $name = "Bf $name";
	} elsif ($file =~ /([us])bahnhof/) {
	    $name = uc($1)." ".$name;
	}

	my $cat = $r->[Strassen::CAT];

	if (@c == 1) {
	    my $type = cat2type($cat, $file, "poi");
	    next if !defined $type;
	    my $is_city = "N";
	    my $end_level = 0;
	    if ($file =~ /^orte/) {
		$is_city = "Y";
		if ($cat =~ /^[56]$/) {
		    $end_level = 5;
		} elsif ($cat =~ /^[34]$/) {
		    $end_level = 4;
		} elsif ($cat =~ /^[2]$/) {
		    $end_level = 3;
		} elsif ($cat =~ /^[01]$/) {
		    $end_level = 2;
		}
	    } elsif ($cat eq 'Pl') {
	        $end_level = 0;
	    }
	    $out .= <<EOF;
[POI]
Type=$type
Label=$name
City=$is_city
Data0=($c[0]->[0],$c[0]->[1])
EndLevel=$end_level
[END-POI]

EOF
	} elsif ($cat =~ /^F:(.*)/) {
	    $cat = $1;
	    my $type = cat2type($cat, $file, "polygon");
	    next if !defined $type;

	    my @island_data;
	    if ($cat =~ m{^W\d?$}) {
		# look for islands
		while(1) {
		    my $r_i = $s->peek;
		    my @c = @{ $r_i->[Strassen::COORDS] };
		    last if (!@c || $r_i->[Strassen::CAT] ne 'F:I');
		    convert_coords(\@c);
		    push @island_data, make_polygon_coords(\@c);
		    $s->next; # increment iterator
		}
	    }

	    $out .= <<EOF;
[POLYGON]
Type=$type
; XXX werden diese ignoriert?
Label=$name
EOF
	    
	    $out .= make_polygon_coords(\@c);
	    $out .= join "", @island_data;
	    $out .= <<EOF;
EndLevel=$levels
[END-POLYGON]

EOF
	    
	} else {
	    my $type = cat2type($cat, $file, "polyline");
	    next if !defined $type;
	    $out .= <<EOF;
[POLYLINE]
Type=$type
Label=$name
DirIndicator=0
EOF
	    my $data0 = join(",", map {
		"(" . $_->[0] . "," . $_->[1]  . ")"
	    } @c) . "\n";
	    $out .= "Data0=" . $data0;
	    my $end_level = $levels;
	    if ($file =~ /^(non-faked-)?strassen$/) {
		$end_level = 1;
		if ($cat ne 'NN' && $cat ne 'N') {
		    $end_level = 2;
		    if ($cat ne 'H') {
			$end_level = 3;
		    }
		}
	    }
	    $out .= <<EOF;
EndLevel=$end_level
[END-POLYLINE]

EOF
	}
    }
    print STDERR "\n";
}

print $out;

sub cat2type {
    my($cat, $file, $rgn_type) = @_;
    my $cat_attrib;
    if ($cat =~ /^(.*?)::(.*)$/) {
	$cat = $1;
	$cat_attrib = $2;
    }

    # Cat;Cat is not handled yet, see DirIndicator above? XXX

    # combined street+quality category e.g. HH-Q0
    return 10 if $cat =~ m{-Q3[+-]?$}; # Unpaved Road - thin
    return 6  if $cat =~ m{-Q2[+-]?$}; # Road - thin
    return 4  if $cat =~ m{^NN-Q.*}; # Arterial Road - medium
    # fall through for other categories

    # normal street categories
    return 2 if $cat =~ m{^B$anyquality$} || $cat =~ m{^HH$anyquality$}; # Principal HWY-thick
    return 3 if $cat =~ m{^H$anyquality$}; # Principal HWY - medium
    return 4 if $cat =~ m{^N$anyquality$}; # Arterial Road - medium
    return 6 if $cat =~ m{^NN$anyquality$}; # Road - thin

    if ($file =~ /[rus]bahnhof$/) {
        return 2816 if $cat =~ /^[RUS][ABCGP]?$/; # namedpoint
        return undef if $cat =~ /^[RUS](0|Bau)$/;
    } else {
        return 20 if $cat =~ /^[RUS][ABCGP]?$/; # Railroad
        return undef if $cat =~ /^[RUS](0|Bau)$/;
    }
    if ($cat eq 'Pl') {
	if ($rgn_type eq 'poi') {
	    # Namedpoint (small point)
	    return 2816;
	} else {
	    return 4;
	}
    }
    return 0x07 if $cat eq 'Ae'; # Airport
    return 0x17 if $cat =~ /^P         (above)?$/x && $rgn_type eq 'polygon';
    return 0x17 if $cat =~ /^Green     (above)?$/x && $rgn_type eq 'polygon'; # something like Gartenbauamt...
    return 0x50 if $cat =~ /^Forest    (above)?$/x && $rgn_type eq 'polygon'; # XXX Woods wrong?
    return 0x1a if $cat =~ /^Cemetery  (above)?$/x && $rgn_type eq 'polygon';
    return 0x4e if $cat =~ /^Orchard   (above)?$/x && $rgn_type eq 'polygon';
    return 0x19 if $cat =~ /^Sport     (above)?$/x && $rgn_type eq 'polygon';
    return 0x0c if $cat =~ /^Industrial(above)?$/x && $rgn_type eq 'polygon';
    return undef if $cat =~ /^Mine     (above)?$/x && $rgn_type eq 'polygon'; # no definition available
    return 0x3c if $cat =~ /^W\d?$/ && $rgn_type eq 'polygon';
    return 0x1f if $cat =~ /^W\d?$/ && $rgn_type eq 'polyline';
    return 0x13 if $cat eq 'I' && $rgn_type eq 'polygon'; # 0x4b=background -> problems?
    if ($file =~ /^orte/) {
	return 0x0c if $cat =~ /^[0]$/;
	return 0x0b if $cat =~ /^[1]$/;
	return 0x08 if $cat =~ /^[2]$/;
	return 0x06 if $cat =~ /^[3]$/;
	return 0x05 if $cat =~ /^[4]$/;
	return 0x03 if $cat =~ /^[5]$/;
	return 0x01 if $cat =~ /^[6]$/;
    }
    return 0x1d if $cat eq 'Z' && $file =~ /^(berlin|potsdam)$/; # County Boundary
    return 0x1e if $cat eq 'Z' && $file =~ /^deutschland$/; # International Boundary
    return 0x1a if $cat eq 'Q'; # Ferry
    return 0x01 if $cat =~ /^\?+/; # major highway --- nicht zu übersehen!
    return 0x4500 if $file =~ /kneipen$/; # 0x4500 restaurant, maybe also 0x4600 for bars
    warn "Unhandled cat <$cat>\n";
    #return 22; # Trail
    undef;
}

sub convert_strname {
    my $strname = shift;
    $strname = Strasse::strip_bezirk($strname);
    $strname =~ s{[()]}{}g;
    encode_string($strname);
}

sub encode_string {
    my($string) = @_;
    if ($codepage) {
	if ($codepage eq '1252') {
	    # From the cgpsmapper manual: "All labels must be written
	    # in CAPITALS if a codepage is used". Hmmm...
	    use locale; # assuming an ISO-8859-1-styled locale is used
	    uc $string;
	} else {
	    die "Cannot handle codepage $codepage";
	}
    } else {
	require Text::Unidecode;
	Text::Unidecode::unidecode($string);
    }
}

sub convert_coords {
    my $c_ref = shift;
    @$c_ref = map {
	my($x,$y) = split /,/, $_;
	my($long, $lat) = $Karte::Polar::obj->trim_accuracy
	    ($Karte::Polar::obj->standard2map($x,$y)
	    );
	[$lat,$long];
    } @$c_ref;
}

sub make_polygon_coords {
    my($c) = @_;

    if ("@{$c->[0]}" eq "@{$c->[-1]}") {
	pop @$c;
    }
    my $data0 = join(",", map {
	"(" . $_->[0] . "," . $_->[1]  . ")"
    } @$c) . "\n";
    "Data0=" . $data0;
}

__END__
