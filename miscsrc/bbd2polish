#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: bbd2polish,v 1.36 2009/01/24 10:45:17 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2005 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

# Convert from a set of bbd files into polish format for cgpsmapper

# For cgpsmapper see http://gps.chrisb.org/en/download.htm

# Usage:
#  .../bbbike/miscsrc/bbd2polish              > /tmp/bbbike.mp
#  .../bbbike/miscsrc/bbd2polish -mapset brb  > /tmp/brb.mp
#  .../bbbike/miscsrc/bbd2polish -mapset wide > /tmp/wide.mp
#  .../bbbike/miscsrc/bbd2polish -mapset fragezeichen > /tmp/fragezeichen.mp
#
# And then use cgpsmapper to convert the mp files to img files
# Use sendmap to send the img files to the Garmin device.

# TODOs
# * make N and NN the same category
# * use thinner streets
# * optionally add bab (maybe a map of its own)
# * make configurable everything
# * create a "legend" map, which shows just all street etc. types

use strict;
use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	);
use Strassen::Core;
use Strassen::Strasse;
use Strassen::MultiStrassen;
use Strassen::StrassenNetz;
use Karte::Polar;
use Karte::Standard;
use Getopt::Long;
use VectorUtil qw(get_polygon_center);

my $codepage; # eg. 1252
my $mapset = "b";
my @layer;
my $strcatqual;
my $datadir;
my $vehicle = "bike";
my $id;
my $name;
if (!GetOptions("mapset=s" => \$mapset,
		"layer=s\@" => \@layer,
		"codepage=s" => \$codepage,
		"strcatqual!" => \$strcatqual, # combined street/quality layer
		"datadir=s" => \$datadir,
		"vehicle=s" => \$vehicle,
		"id=i" => \$id,
		"name=s" => \$name,
	       )) {
    die <<EOF;
usage: $0 [-mapset [ b | brb | wide | all ] ] [-strcatqual]
          [-codepage ...] [-vehicle bike|car] [-datadir ...]
	  [-layer ... [-layer ...]] [-id ...] [-name ...]

-mapset ...:  build Berlin (b), Brandenburg (brb) or whole map
-layer:       use the specific layer(s) instead of predefined mapset
-strcatqual:  build an alternative map which takes qualities into account
              (only for vehicle=bike really useful)
-codepage:    use a different codepage (does this work at all?)
-datadir ...: data directory to use instead of the default data directory
-vehicle bike|car: create map for cyclists (this is the default) or car drivers
-id ...:      id of image, will be created automatically if not given
-name ...:    name of image, will be created automatically if not given

EOF

}

if ($datadir) {
    @Strassen::datadirs = ($datadir);
}

my $anyquality = qr{(?:-Q\d[+-]?)?};
my $base_id = 10000099; # XXX how to choose img id? is there a manual? or just increment?
if (!$id) {
    $id = {"b"    => $base_id,
	   "brb"  => $base_id+1,
	   "wide" => $base_id+2,
	   "fragezeichen" => $base_id+3,
	   "all"  => $base_id+4,
	  }->{$mapset};
    if ($strcatqual) {
	$id += 5; # 5 is one more than elements above
    }
}
if (!$name) {
    $name = {"b"    => "BBBike map",
	     "brb"  => "BBBike BRB map",
	     "wide" => "BBBike wide map",
	     "fragezeichen" => "BBBike Fragezeichen",
	     "all"  => "BBBike complete map",
	    }->{$mapset};
    if ($strcatqual) {
	$name .= " (by quality)";
    }
}
die "Cannot set name and/or id for <$mapset>"
    if !defined $name || !defined $id;

my $levels = 5;
my $use_dictionary = 0;

my $out = "";
$out .= <<EOF;
[IMG ID]
ID=$id
Name=$name
EOF
if (!$codepage) {
    $out .= <<EOF;
LBLcoding=6
EOF
} else {
    $out .= <<EOF;
LBLcoding=9
Codepage=$codepage
EOF
}
$out .= <<EOF;
;; transparency is a bad idea, because the base map is not
;; turnable off, at least on etrex vista
; Transparent=Y
PreProcess=F
;TreSize=800
TreSize=3000
Elevation=m
Levels=@{[ $levels + 1 ]}
; with Pl, POI etc.
Level0=24
; with NN/N/NH
Level1=22
; with H
Level2=20
; with HH/B
Level3=18
; with HH/B
Level4=16
; empty
Level5=14
Zoom0=1
Zoom1=2
Zoom2=3
Zoom3=4
Zoom4=5
Zoom5=6
[END-IMG ID]

EOF

if ($use_dictionary) {
    $out .= <<EOF;
[DICTIONARY]
;Since the default is to import all elements, it is not neccesary to define filters for layer 0
;RGN10 = POI
;Level0RGN10=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

Level1RGN10=111111111111111111111111111111100000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level2RGN10=111111111111111111111111111111100000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

;           0              1               2               3               4               5               6 
;           123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0

;RGN20 = POI with cities
;Level0RGN20=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN20=111111111100000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level2RGN20=111111110000000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level3RGN20=111111100000000000011111111111110000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

;RGN40 = polyline
;Level0RGN40=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN40=111110001110010000011100111111101101101111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Level2RGN40=111000001110010000011100111111100100100111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Level3RGN40=110000001110010000011100111111100100100111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

;RGN80 = polygon
;Level0RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
Level1RGN80=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
[END-DICTIONARY]

;[DICTIONARY]
;;Level0RGN10=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
;[END-DICTIONARY]

EOF
}

my @files;
if (@layer) {
    @files = @layer;
} else {
    if ($mapset eq 'b') {
	@files = qw(strassen wasserstrassen flaechen sbahn sbahnhof ubahn ubahnhof berlin faehren kneipen);
	using_non_faked_strassen(\@files);
    } elsif ($mapset eq 'brb') {
	@files = qw(orte landstrassen wasserumland rbahn rbahnhof potsdam);
    } elsif ($mapset eq 'wide') {
	@files = qw(orte2 landstrassen2 wasserumland2 deutschland);
    } elsif ($mapset eq 'fragezeichen') {
	@files = qw(fragezeichen);
    } elsif ($mapset eq 'all') {
	@files = qw(strassen wasserstrassen flaechen sbahn sbahnhof ubahn ubahnhof berlin faehren kneipen
		    orte landstrassen wasserumland rbahn rbahnhof potsdam
		    orte2 landstrassen2 wasserumland2 deutschland
		    fragezeichen
		    sehenswuerdigkeit comments_scenic
		   );
	using_non_faked_strassen(\@files);
    } else {
	die "Unknown mapset <$mapset>";
    }
    vehicle_fileset(\@files);
}

my $qs_net_net;

for my $file (@files) {
    print STDERR "$file...";

    my $use_full_name = $file =~ m{fragezeichen};
    my $start_end_coords = $file =~ m{comments_scenic};

    my $convert_strname = sub {
	my $strname = shift;
	$strname = Strasse::strip_bezirk($strname)
	    if !$use_full_name;
	$strname =~ s{[()]}{}g;
	$strname =~ s{(\s+)-(\s+)}{..}g; # Garmin bug? Street names matching this regexp won't be shown.
	encode_string($strname);
    };

    my $s = eval { Strassen->new($file) };
    if (!$s) {
	if ($datadir) {
	    # with custom datadir we do not need everything
	    warn "Cannot open <$file>, skipping...\n";
	    next;
	} else {
	    die $@;
	}
    }

    # combine street category + street quality
    if ($strcatqual && $file =~ m{\b(?:strassen|landstrassen|landstrassen2)\b}) {
	if (!$qs_net_net) {
	    my $qs = MultiStrassen->new("qualitaet_s", "qualitaet_l");
	    my $qs_net = StrassenNetz->new($qs);
	    $qs_net->make_net_cat(-obeydir => 0, -usecache => 1); # XXX -obeydir? should combine somehow the categories of both directions and choose the worse one
	    $qs_net_net = $qs_net->{Net};
	}

	my $new_s = Strassen->new;
	$s->init;
	while (1) {
	    my $r = $s->next;
	    my @c = @{ $r->[Strassen::COORDS] };
	    last if !@c;
	    my $cat = $r->[Strassen::CAT];
	    if ($cat eq 'Pl') {
		$new_s->push($r);
	    } else {
		my $last_cat;
		my @new_c = $c[0];
		for my $c_i (1 .. $#c) {
		    my $this_cat = $cat . "-" . ($qs_net_net->{$c[$c_i-1]}{$c[$c_i]} || "Q0"); # XXX hin vs. rueck???
		    if (!defined $last_cat || $this_cat eq $last_cat) {
			push @new_c, $c[$c_i];
		    } else {
			$new_s->push([$r->[Strassen::NAME], [@new_c], $last_cat]);
			@new_c = ($c[$c_i-1], $c[$c_i]);
		    }
		    $last_cat = $this_cat;
		}
		if (@new_c >= 2) {
		    $new_s->push([$r->[Strassen::NAME], [@new_c], $last_cat]);
		}
	    }
	}
	$s = $new_s;
    }

    $s->init;
    while(1) {
	my $r = $s->next;
	my @c = @{ $r->[Strassen::COORDS] };
	last if !@c;

	convert_coords(\@c);

	my $name = $convert_strname->($r->[Strassen::NAME]);
	my $add;
	($name, $add) = split(/\|/, $name);
	$name = "" if !defined $name;

	if ($file =~ /landstrassen/) {
	    if ($name =~ /\S+\s-\s\S+/) {
		$name = "";
	    }
	} elsif ($file =~ /rbahnhof/) {
	    $name = "Bf $name";
	} elsif ($file =~ /([us])bahnhof/) {
	    $name = uc($1)." ".$name;
	}

	my $cat = $r->[Strassen::CAT];

	if (@c == 1
	    || $start_end_coords
	    || $file =~ m{sehenswuerdigkeit} # XXX what about polygon sehenswuerdigkeiten?
	   ) { # one-point and POI-like layers
	    my $type = cat2type($cat, $file, "poi");
	    next if !defined $type;
	    my $is_city = "N";
	    my $end_level = 0;
	    if ($file =~ /^orte/) {
		$is_city = "Y";
		if ($cat =~ /^[56]$/) {
		    $end_level = 5;
		} elsif ($cat =~ /^[34]$/) {
		    $end_level = 4;
		} elsif ($cat =~ /^[2]$/) {
		    $end_level = 3;
		} elsif ($cat =~ /^[01]$/) {
		    $end_level = 2;
		}
	    } elsif ($cat eq 'Pl') {
	        $end_level = 0;
	    }

	    my @out_c;
	    if (@c == 1) {
		@out_c = @c;
	    } elsif ($start_end_coords) {
		@out_c = @c[0, -1];
	    } else {
		@out_c = [ get_polygon_center(map { @$_ } @c) ];
	    }
	    for my $c (@out_c) {
		$out .= <<EOF;
[POI]
Type=$type
Label=$name
City=$is_city
Data0=($c->[0],$c->[1])
EndLevel=$end_level
[END-POI]

EOF
	    }
	} elsif ($cat =~ /^F:(.*)/) {
	    $cat = $1;
	    my $type = cat2type($cat, $file, "polygon");
	    next if !defined $type;

	    my @island_data;
	    if ($cat =~ m{^W\d?$}) {
		# look for islands
		while(1) {
		    my $r_i = $s->peek;
		    my @c = @{ $r_i->[Strassen::COORDS] };
		    last if (!@c || $r_i->[Strassen::CAT] ne 'F:I');
		    convert_coords(\@c);
		    push @island_data, make_polygon_coords(\@c);
		    $s->next; # increment iterator
		}
	    }

	    $out .= <<EOF;
[POLYGON]
Type=$type
; XXX werden diese ignoriert?
Label=$name
EOF
	    
	    $out .= make_polygon_coords(\@c);
	    $out .= join "", @island_data;
	    $out .= <<EOF;
EndLevel=$levels
[END-POLYGON]

EOF
	    
	} else {
	    my $type = cat2type($cat, $file, "polyline");
	    next if !defined $type;
	    $out .= <<EOF;
[POLYLINE]
Type=$type
Label=$name
DirIndicator=0
EOF
	    my $data0 = join(",", map {
		"(" . $_->[0] . "," . $_->[1]  . ")"
	    } @c) . "\n";
	    $out .= "Data0=" . $data0;
	    my $end_level = $levels;
	    if ($file =~ /^(non-faked-)?strassen$/) {
		$end_level = 1;
		if ($cat ne 'NN' && $cat ne 'N') {
		    $end_level = 2;
		    if ($cat ne 'H') {
			$end_level = 3;
		    }
		}
	    }
	    $out .= <<EOF;
EndLevel=$end_level
[END-POLYLINE]

EOF
	}
    }
    print STDERR "\n";
}

print $out;

sub cat2type {
    my($cat, $file, $rgn_type) = @_;
    my $cat_attrib;
    if ($cat =~ /^(.*?)::(.*)$/) {
	$cat = $1;
	$cat_attrib = $2;
    }

    # Cat;Cat is not handled yet, see DirIndicator above? XXX

    # combined street+quality category e.g. HH-Q0
    return 10 if $cat =~ m{-Q3[+-]?$}; # Unpaved Road - thin
    return 6  if $cat =~ m{-Q2[+-]?$}; # Road - thin
    return 4  if $cat =~ m{^NN-Q.*}; # Arterial Road - medium
    # fall through for other categories

    # normal street categories
    return 2 if $cat =~ m{^B$anyquality$} || $cat =~ m{^HH$anyquality$}; # Principal HWY-thick
    return 3 if $cat =~ m{^H$anyquality$}; # Principal HWY - medium
    return 4 if $cat =~ m{^NH$anyquality$}; # Arterial Road - medium
    return 4 if $cat =~ m{^N$anyquality$}; # Arterial Road - medium
    return 6 if $cat =~ m{^NN$anyquality$}; # Road - thin

    # Thickness of lines:
    #   1
    #   2, 3
    #   4, 5
    #   6         unfortunately in small scales *thicker* than 4, 5! See below.
    #   7, 10

    if ($file =~ /[rus]bahnhof$/) {
        return 2816 if $cat =~ /^[RUS][ABCGP]?$/; # namedpoint
        return undef if $cat =~ /^[RUS](0|Bau)$/;
    } else {
        return 20 if $cat =~ /^[RUS][ABCGP]?$/; # Railroad
        return undef if $cat =~ /^[RUS](0|Bau)$/;
    }
    if ($cat eq 'Pl') {
	if ($rgn_type eq 'poi') {
	    # Namedpoint (small point)
	    return 2816;
	} else {
	    return 4;
	}
    }
    return 0x07 if $cat eq 'Ae'; # Airport
    return 0x07 if $cat eq 'ex-Ae'; # ex-Airport, XXX maybe find a better signature
    return 0x17 if $cat =~ /^P         (above)?$/x && $rgn_type eq 'polygon';
    return 0x17 if $cat =~ /^Green     (above)?$/x && $rgn_type eq 'polygon'; # something like Gartenbauamt...
    return 0x50 if $cat =~ /^Forest    (above)?$/x && $rgn_type eq 'polygon'; # XXX Woods wrong?
    return 0x1a if $cat =~ /^Cemetery  (above)?$/x && $rgn_type eq 'polygon';
    return 0x4e if $cat =~ /^Orchard   (above)?$/x && $rgn_type eq 'polygon';
    return 0x19 if $cat =~ /^Sport     (above)?$/x && $rgn_type eq 'polygon';
    return 0x0c if $cat =~ /^Industrial(above)?$/x && $rgn_type eq 'polygon';
    return undef if $cat =~ /^Mine     (above)?$/x && $rgn_type eq 'polygon'; # no definition available
    return 0x3c if $cat =~ /^W\d?$/ && $rgn_type eq 'polygon';
    return 0x1f if $cat =~ /^W\d?$/ && $rgn_type eq 'polyline';
    return 0x13 if $cat eq 'I' && $rgn_type eq 'polygon'; # 0x4b=background -> problems?
    if ($file =~ /^orte/) {
	return 0x0c if $cat =~ /^[0]$/;
	return 0x0b if $cat =~ /^[1]$/;
	return 0x08 if $cat =~ /^[2]$/;
	return 0x06 if $cat =~ /^[3]$/;
	return 0x05 if $cat =~ /^[4]$/;
	return 0x03 if $cat =~ /^[5]$/;
	return 0x01 if $cat =~ /^[6]$/;
    }
    return 0x1d if $cat eq 'Z' && $file =~ /^(berlin|potsdam)$/; # County Boundary
    return 0x1e if $cat eq 'Z' && $file =~ /^deutschland$/; # International Boundary
    return 0x1a if $cat eq 'Q'; # Ferry
    return 0x1a if $cat eq 'QQ'; # Ferry
    return 0x01 if $cat =~ m{^\?+}; # major highway --- nicht zu übersehen!
    return 0x01 if $cat =~ m{^BAB(?:\b|::Tu|::Br)}; # major highway (this is for real!)
    return 0x4500 if $file =~ /kneipen$/; # 0x4500 restaurant, maybe also 0x4600 for bars
    return 0x5200 if $file =~ m{comments_scenic}; # Scenic Area
    # sehenswuerdigkeiten
    return 0x6404 if $cat =~ m{IMG:church}; # visible
    return 0x6408 if $cat =~ m{IMG:hospital}; # visible
    return 0x2C02 if $cat =~ m{IMG:museum}; # Museum/History, not visible
    return 0x2E04 if $cat =~ m{\bShop\b}; # Shopping Center, not visible
    return 0x2D01 if $cat =~ m{IMG:theater}; # Theater, not visible
    return 0x2F04 if $cat =~ m{IMG:airport}; # visible
    return 0x4C00 if $cat =~ m{IMG:touristinfo}; # Information, visible
    return undef if $file =~ m{sehenswuerdigkeit}; # ignore others

    warn "Unhandled cat <$cat>\n";
    undef;
}

sub encode_string {
    my($string) = @_;
    if ($codepage) {
	if ($codepage eq '1252') {
	    # From the cgpsmapper manual: "All labels must be written
	    # in CAPITALS if a codepage is used". Hmmm...
	    use locale; # assuming an ISO-8859-1-styled locale is used
	    uc $string;
	} else {
	    die "Cannot handle codepage $codepage";
	}
    } else {
	require Text::Unidecode;
	Text::Unidecode::unidecode($string);
    }
}

sub convert_coords {
    my $c_ref = shift;
    @$c_ref = map {
	my($x,$y) = split /,/, $_;
	my($long, $lat) = $Karte::Polar::obj->trim_accuracy
	    ($Karte::Polar::obj->standard2map($x,$y)
	    );
	[$lat,$long];
    } @$c_ref;
}

sub make_polygon_coords {
    my($c) = @_;

    if ("@{$c->[0]}" eq "@{$c->[-1]}") {
	pop @$c;
    }
    my $data0 = join(",", map {
	"(" . $_->[0] . "," . $_->[1]  . ")"
    } @$c) . "\n";
    "Data0=" . $data0;
}

sub using_non_faked_strassen {
    my($files_ref) = @_;
    return if ($datadir); # not with custom datadir
    for my $i (0 .. $#$files_ref) {
	if ($files_ref->[$i] eq 'strassen') {
	    my $non_faked_strassen = "$FindBin::RealBin/../tmp/non-faked-strassen";
	    if (-r $non_faked_strassen) {
		if (-M $non_faked_strassen > -M "$FindBin::RealBin/../data/strassen") {
		    warn "WARN: Cannot use non-faked-strassen; it is older than strassen!\n";
		} else {
		    $files_ref->[$i] = $non_faked_strassen;
		    warn "NOTE: Using non-faked-strassen instead of strassen...\n";
		}
	    }
	}
    }
}

sub vehicle_fileset {
    my($files_ref) = @_;
    if ($vehicle eq 'bike') {
    } elsif ($vehicle eq 'car') {
	@$files_ref = grep { $_ ne "fragezeichen" } @$files_ref;
	unshift @$files_ref, "strassen_bab";
    }
}

__END__

# Problematik mit N vs. NN: im derzeitigen Setting (NN ist 6, N ist 4)
# erscheint bei großen Maßstäben bis 800m NN breiter als N. Ab 500m
# runter sieht es richtig aus. Normalerweise wird cat=6 im Garmin bei
# großen Maßstäben nicht gezeichnet und vielleicht ist es deshalb nie
# aufgefallen. Das gilt für die Einstellung "normale" Details. Bei
# "vise" ist die Grenze erst bei 1.2km (gut) - 2km (falsch). Bei
# "najvise" ist es bei 2km (gut) - 3km (falsch).
