#!/usr/bin/perl
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2017,2018,2019,2020,2021,2022,2023,2024 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: srezic@cpan.org
# WWW:  http://bbbike.de
#

use FindBin;
use lib "$FindBin::RealBin/..", "$FindBin::RealBin/../lib";

use Doit;
use Doit::Log;
use Doit::Util qw(in_directory copy_stat);

use Cwd qw(realpath);
use File::Basename qw(basename dirname);
use File::Glob qw(bsd_glob);
use File::Temp qw(tempdir);
use Getopt::Long;
use Hash::Util qw(lock_keys);
use POSIX qw(strftime WNOHANG);
use Time::HiRes ();

use BBBikeUtil qw(save_pwd2 bbbike_root);

my %codename_to_packagerepos;
# list generated with following command on mydebs system:
#     perl -ne 'print " $1" if /Codename: (\S+)/' /srv/www/debian-repo/conf/distributions ; echo
for my $codename (qw(squeeze lenny etch wheezy jessie stretch lucid precise trusty xenial bionic buster focal bullseye bookworm)) {
    $codename_to_packagerepos{$codename}->{'mydebs.bbbike.de'} = 1;
}
for my $codename (qw(bionic focal jammy)) {
    $codename_to_packagerepos{$codename}->{'bbbike-ppa'} = 1;
}

sub usage (;$) {
    die((defined $_[0] ? $_[0]."\n\n" : '') . <<EOF);
usage: $0 [--dry-run] gui | cgi | ci | build-deb [options]
EOF
}

sub usage_gui (;$) {
    die((defined $_[0] ? $_[0]."\n\n" : '') . <<EOF);
usage: $0 [--dry-run] gui [--dist debian|ubuntu|...] [--distver bullseye|...] [--src local|github] [--bbbike-args "..."] [--branch ...]
	 [--no-feature-pdf] [--no-feature-svg] [-no-feature-remote]
	 [--debug] [--no-install-recommends] [--install-suggests] [--invalidate-apt] [--docker-image owner/name:tag]

Note that --install-suggests would install quite a lot...
EOF
}

sub usage_ci (;$) {
    die((defined $_[0] ? $_[0]."\n\n" : '') . <<EOF);
usage: $0 [--dry-run] ci [--dist debian|ubuntu|...] [--distver stretch|...] [--src local|github] [--perl-ver X.Y.Z] [--env KEY=VAL ...] [--branch ...]
	 [--with-data-build] [--no-cache] [--invalidate-apt] [--image-variant ...]
EOF
}

sub usage_build_deb (;$) {
    die((defined $_[0] ? $_[0]."\n\n" : '') . <<EOF);
usage: $0 [--dry-run] build-dev [--dist debian|ubuntu|...] [--distver stretch|...] [--distfile BBBike-X.YY.tar.gz] [--continue]
	 [--invalidate-apt]
EOF
}

sub usage_cgi (;$) {
    die((defined $_[0] ? $_[0]."\n\n" : '') . <<EOF);
usage: $0 [--dry-run] cgi [--dist debian|ubuntu|...] [--distver stretch|...] [--test]
	 [--invalidate-apt] [--[no]mapserver] [--use-bbbike-ppa]
EOF
}

sub _dockerfile_frag_src ($) {
    my $optref = shift;
    my $dockerfile = '';

    # Get the source, either from github or local src
    my $branch_args = '';
    if ($optref->{branch}) {
	$branch_args = " --branch $optref->{branch}";
    }
    if ($optref->{src} eq 'github') {
	$dockerfile .= <<EOF;
RUN git clone --depth=1 https://github.com/eserte/bbbike.git$branch_args /bbbike
EOF
    } elsif ($optref->{src} eq 'local') {
	$dockerfile .= <<EOF;
COPY bbbike /bbbike
EOF
    } else {
	usage "Invalid --src value '$optref->{src}', only 'github' and 'local' are known";
    }
    $dockerfile;
}

sub _dockerfile_apt_auth ($) {
    my $optref = shift;
    my $dockerfile = '';

    if ($optref->{distver} =~ m{^(wheezy|jessie$)}) {
	$dockerfile .= <<EOF;
RUN echo "APT::Get::AllowUnauthenticated 1;" > /etc/apt/apt.conf.d/02allow-unsigned
EOF
    }
    $dockerfile;
}

sub _dockerfile_fix_sources_list ($) {
    my $optref = shift;
    my $dockerfile = '';

    if ($optref->{distver} =~ m{^(wheezy|jessie|stretch)$}) {
	$dockerfile .= <<EOF;
RUN echo 'deb [check-valid-until=no] http://archive.debian.org/debian $optref->{distver} main'                   >  /etc/apt/sources.list
RUN echo 'deb [check-valid-until=no] http://archive.debian.org/debian-security/ $optref->{distver}/updates main' >> /etc/apt/sources.list
EOF
    }
    $dockerfile;
}

sub _dockerfile_invalidate_cache () {
    <<"EOF";
# Just a hack to make sure that the following lines
# are executed at least once a day
RUN echo @{[ POSIX::strftime("%F", localtime) ]}
EOF
}

sub _docker_build_with_retry ($$$) {
    my($doit, $docker_image_tag, $cmdline) = @_;
    my @docker_build_cmd = (qw(docker build), @$cmdline);
    for my $try (1..2) {
	if (!eval {
	    $doit->system(@docker_build_cmd);
	    1;
	}) {
	    if ($try == 1) {
		$doit->system(qw(docker pull), $docker_image_tag);
	    } else {
		error "Error running '@docker_build_cmd': $@";
	    }
	} else {
	    last;
	}
    }
}

sub gui {
    my($doit, %opt) = @_;
    lock_keys %opt;

    my $add_apt_args = "";
    if (!$opt{'install-recommends'}) {
	$add_apt_args .= " --no-install-recommends";
    }
    if ($opt{'install-suggests'}) {
	$add_apt_args .= " --install-suggests";
    }

    my @apikeyfiles = ('.bingapikey', '.openweathermap_appid', '.opencageapikey');

    $doit->make_path("$ENV{HOME}/.docker-bbbike");

    my $docker_cmd;

    my $docker_image = $opt{'docker-image'} // "$opt{dist}:$opt{distver}";

    my $dockerfile = <<EOF;
FROM $docker_image
EOF
    $dockerfile .= _dockerfile_invalidate_cache if $opt{'invalidate-apt'};
    $dockerfile .= _dockerfile_fix_sources_list(\%opt);
    $dockerfile .= _dockerfile_apt_auth(\%opt);

    my $username;
    if ($^O ne 'MSWin32') {
	my $uid = $<;
	$username = (getpwuid($uid))[0];
	$dockerfile .= <<"EOF";
RUN adduser --disabled-password --force-badname -u $uid --gecos '' $username
EOF
    }

    if ($opt{src} =~ m{^(github|local)$}) {
	my @packages = qw(perl-tk);
	if ($opt{'feature-pdf'}) {
	    push @packages, qw(libcairo-perl libpango-perl);
	}
	if ($opt{'feature-svg'}) {
	    push @packages, qw(librsvg2-bin);
	}
	if ($opt{'feature-remote'}) {
	    push @packages, qw(libwww-perl libxml-libxml-perl);
	}
	if ($opt{src} eq 'github') {
	    push @packages, 'git';
	}
	$dockerfile .= <<"EOF";
RUN apt-get update && apt-get install -qqy @packages
EOF
	if ($opt{src} eq 'github') {
	    $dockerfile .= <<'EOF';
RUN mkdir bbbike
EOF
	    if (defined $username) {
		$dockerfile .= <<"EOF";
RUN chown $username bbbike
EOF
	    }
	    my $branch_args = '';
	    if ($opt{branch}) {
		$branch_args = " --branch $opt{branch}";
	    }
	    $docker_cmd = "git clone --depth=1 https://github.com/eserte/bbbike.git$branch_args && bbbike/bbbike $opt{'bbbike-args'}";
	} elsif ($opt{src} eq 'local') {
	    $docker_cmd = "/bbbike/bbbike $opt{'bbbike-args'}";
	}
    } elsif ($opt{src} =~ m{\.deb$}) {
	my $base_src = basename $opt{src};
	$dockerfile .= <<EOF;
COPY $base_src /tmp/
COPY install-deb /tmp/
WORKDIR /tmp
RUN apt-get update
RUN sh install-deb $add_apt_args ./$base_src
EOF
	$docker_cmd = "bbbike $opt{'bbbike-args'}";
    } else {
	usage "Invalid --src value '$opt{src}', only 'github', 'local' or a path to a .deb are possible";
    }

    if (defined $username) {
	$dockerfile .= <<"EOF";
USER $username
EOF
    }

    $dockerfile .= "CMD $docker_cmd\n";

    # Need to install socat on MacOSX, and do also some pre-checking.
    local %ENV = %ENV; # actually needed only for darwin
    if ($^O eq 'darwin') {
	if (!$ENV{DISPLAY}) {
	    error "No DISPLAY environment variable --- maybe Xquartz has to be started?";
	}
	if (!-S $ENV{DISPLAY}) {
	    error "Content of $ENV{DISPLAY} should be path to X socket";
	}
	$doit->add_component('brew');
	$doit->brew_install_packages(qw(socat));
    }

    my $docker_context_dir = tempdir("docker_context_XXXXXXXX", TMPDIR => 1, CLEANUP => 1);
    $doit->write_binary("$docker_context_dir/Dockerfile", $dockerfile);

    if ($opt{src} =~ m{\.deb$}) {
	for my $copy_def (
			  [$opt{src}, $docker_context_dir],
			  ["$FindBin::RealBin/../port/debian/helper/install-deb", $docker_context_dir],
			 ) {
	    my($src,$dest) = @$copy_def;
	    $doit->copy($src, $dest);
	    copy_stat($src, "$dest/" . basename($src));
	}
    }

    my $tag = 'bbbike-gui-'.$opt{dist}.'-'.$opt{distver};
    in_directory {
	_docker_build_with_retry($doit, "$opt{dist}:$opt{distver}", ['--tag', $tag, '.']);
    } $docker_context_dir;

    my @volume_options;
    if ($opt{src} eq 'local') { push @volume_options, '-v', "$FindBin::RealBin/..:/bbbike:ro" }
    if (defined $username) {
	push @volume_options, '-v', "$ENV{HOME}/.docker-bbbike:/home/$username/.bbbike";
	for my $apikeyfile (@apikeyfiles) {
	    if (-r "$ENV{HOME}/$apikeyfile") {
		push @volume_options, '-v', "$ENV{HOME}/$apikeyfile:/home/$username/$apikeyfile:ro";
	    }
	}
    }

    my @docker_run_args =
	(
	 # SYS_PTRACE is required for strace --- see
	 # http://blog.johngoulah.com/2016/03/running-strace-in-docker/
	 $opt{debug} ? ('--cap-add', 'SYS_PTRACE') : (),
	);
    if ($^O eq 'darwin') {
	my $scope_cleanups = Doit::ScopeCleanups->new;

	my $socat_port = 6098; # should be >= 6000
	my $display = ':' . ($socat_port-6000);
	my $socat_pid = fork;
	error "Can't fork: $!" if !defined $socat_pid;
	if ($socat_pid == 0) {
	    (my $escaped_DISPLAY = $ENV{DISPLAY}) =~ s{:}{\\:}g;
	    my @cmd = ('socat', 'TCP-LISTEN:'.$socat_port.',reuseaddr,fork', "UNIX-CLIENT:$escaped_DISPLAY");
	    info "Running @cmd";
	    exec @cmd;
	    die "Can't run <@cmd>: $!";
	}
	$scope_cleanups->add_scope_cleanup(sub { info "Killing socat process $socat_pid"; kill KILL => $socat_pid });

	# Race condition! Hopefully socat is faster than the following docker command!
	$doit->system('docker', 'run', '-ti',
		      @docker_run_args,
		      '--network=host',
		      @volume_options,
		      '-e', "DISPLAY=host.docker.internal$display",
		      $tag,
		     );
    } else {
	my $XSOCK = '/tmp/.X11-unix';
	my $XAUTH = '/tmp/.docker.xauth';
	$doit->run(['xauth', 'nlist', $ENV{DISPLAY}], '|', ['sed', '-e', 's/^..../ffff/'], '|', ['xauth', '-f', $XAUTH, 'nmerge', '-']);
	$doit->run(['docker', 'run', '-ti',
		    @docker_run_args,
		    '-v', "$XSOCK:$XSOCK", '-v', "$XAUTH:$XAUTH",
		    @volume_options,
		    '-e', "XAUTHORITY=$XAUTH", '-e', "DISPLAY=$ENV{DISPLAY}",
		    $tag,
		   ]);
    }
}

sub ci {
    my($doit, %opt) = @_;
    lock_keys %opt;

    my $t0 = Time::HiRes::time();

    my %default_env =
	(
	 # build config
	 USE_MODPERL                => 1,
	 USE_SYSTEM_PERL            => 1,
	 USE_BBBIKE_PPA             => $codename_to_packagerepos{$opt{'distver'}}->{'bbbike-ppa'} ? 1 : 0,
	 # init_env_vars() is ineffective in this setup, so set it here
	 BBBIKE_LONG_TESTS          => 1,
	 BBBIKE_TEST_SKIP_MAPSERVER => 1,
	 BBBIKE_TEST_GUI            => 0,
	 BBBIKE_TEST_WITH_SELENIUM  => 0,
	 BBBIKE_TEST_FOR_LIVE       => 1,
	 PERL_CPANM_OPT             => "--mirror https://cpan.metacpan.org --mirror http://cpan.cpantesters.org",
	 CPAN_INSTALLER             => "cpm",
	);

    my $bbbike_rootdir = realpath("$FindBin::RealBin/..");
    my $docker_context_dir = tempdir("docker_context_XXXXXXXX", TMPDIR => 1, CLEANUP => 1);

    my $image = "$opt{dist}:$opt{distver}";
    if ($opt{'image-variant'}) {
	$image .= "-" . $opt{'image-variant'};
    }

    if (defined $opt{'cover-dir'}) {
	if ($opt{'with-data-build'}) {
	    error "--cover-dir conflicts with --with-data-build option";
	}
	if (!-d $opt{'cover-dir'}) {
	    $doit->make_path($opt{'cover-dir'});
	}
    }

    ## Build the Dockerfile
    my $dockerfile = <<EOF;
FROM $image

# travis defaults
ENV DEBIAN_FRONTEND noninteractive
# on newer systems sudo does not pass the environment, so another setting is needed
RUN echo "DEBIAN_FRONTEND=noninteractive" >> /etc/environment

EOF

    $dockerfile .= _dockerfile_fix_sources_list(\%opt);

    my($real_dist, $real_distver) = ($opt{dist}, $opt{distver});
    if ($real_dist eq 'perl') { # perl docker images are usually based on debian
	if ($real_distver =~ /-(bullseye|bookworm)$/) {
	    $real_distver = $1;
	    $real_dist = 'debian';
	    warn "WARN: currently docker-bbbike has no support for non-system perl systems. Expect failures.\n";
	} else {
	    die "Cannot handle distver '$real_distver' (maybe the regexp need to be extended?)\n";
	}
    }

    # repository for agrep
    if ($real_dist eq 'debian') {
	my $debhost = $real_distver =~ m{^(wheezy|jessie|stretch)$} ? 'archive.debian.org' : 'ftp.debian.org';
	$dockerfile .= <<EOF;
RUN echo "deb [check-valid-until=no] http://$debhost/debian/ $real_distver non-free" > /etc/apt/sources.list.d/$real_distver-non-free.list
EOF
    } elsif ($real_dist eq 'ubuntu') {
	if ($real_distver =~ m{^(precise|trusty)$}) {
	    $dockerfile .= <<EOF;
RUN echo "deb http://archive.ubuntu.com/ubuntu $real_distver multiverse" > /etc/apt/sources.list.d/$real_distver-multiverse.list
EOF
	} else {
	    # since Ubuntu 16.04 multiverse is enabled by default
	}
    } else {
	die "Unsupported dist $real_dist";
    }

    if ($real_distver eq 'precise') {
	# http/1.1 pipelining used, but mydebs.bbbike.org cannot
	# do it (response: 400 Bad Request). Workaround from
	# http://bnpcs.blogspot.de/2010/11/disable-http-pipelining-in-ubuntu.html
	$dockerfile .= <<EOF;
RUN echo 'Acquire::http::Pipeline-Depth "0";' >> /etc/apt/apt.conf.d/00no-pipeline
EOF
    }

    # In case of unstable networks (seen for some jobs in github
    # actions). Recommendation from https://askubuntu.com/a/1107071/207243
    $dockerfile .= <<EOF;
RUN echo 'Acquire::Retries "3";' > /etc/apt/apt.conf.d/80-retries
EOF

    $dockerfile .= _dockerfile_apt_auth(\%opt);

    # basic packages
    $dockerfile .= _dockerfile_invalidate_cache if $opt{'invalidate-apt'};
    $dockerfile .= <<EOF;
RUN apt-get update -qq && apt-get install -qqy git cpanminus libssl-dev wget
EOF
    if (
	($real_dist eq 'ubuntu' && $real_distver ne 'trusty') ||
	$real_dist eq 'debian'
       ) {
	# Lacking packages in precise and bionic (18.04) (and debian/stretch, lsb-release at least)
	$dockerfile .= <<EOF;
RUN apt-get install -qqy lsb-release sudo make
EOF
    }

    if ($opt{'perl-ver'}) {
	(my $short_perl_ver = $opt{'perl-ver'}) =~ s{\.\d+$}{};
	# Probably travis has only perls for ubuntu trusty and precise
	my $distnumver = { ubuntu => {
				       jammy   => '22.04',
				       focal   => '20.04',
				       bionic  => '18.04',
				       xenial  => '16.04',
				       trusty  => '14.04',
				       precise => '12.04',
				     } }->{$real_dist}->{$real_distver};
	if (!$distnumver) {
	    error "No support for --perl-ver and $real_dist:$real_distver";
	}
	# alternatively the tarballs are also available on https://storage.googleapis.com/travis-ci-language-archives/perl/binaries/$real_dist/$distnumver.04/x86_64/perl-$short_perl_ver.tar.bz2
	$dockerfile .= <<EOF;
RUN apt-get install -qqy bzip2
RUN wget https://s3.amazonaws.com/travis-perl-archives/binaries/$real_dist/$distnumver/x86_64/perl-$short_perl_ver.tar.bz2
RUN tar xf perl-$short_perl_ver.tar.bz2
ENV PATH=/home/travis/perl5/perlbrew/bin:/home/travis/perl5/perlbrew/perls/$opt{'perl-ver'}/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
EOF
	$default_env{USE_SYSTEM_PERL} = '';
    } else {
	# install dummy perlbrew, so at least "perlbrew off" works
	$dockerfile .= <<EOF;
RUN echo "#!/bin/sh" > /usr/bin/perlbrew
RUN chmod 755 /usr/bin/perlbrew
EOF
    }
    $dockerfile .= <<EOF;
COPY bbbike/port/ci/ci-functions.sh /
RUN cat /ci-functions.sh >> ~/.bash_profile
EOF

    # apply default environment, possibly changed by --env options
    my %changed_env; # used later for git-test-note feature list
    for my $key (sort keys %default_env) {
	my $val;
	if (exists $opt{env}->{$key}) {
	    $val = delete $opt{env}->{$key};
	    $changed_env{$key} = $val;
	} else {
	    $val = $default_env{$key};
	}
	$dockerfile .= <<EOF;
ENV $key "$val"
EOF
    }

    # Emulate .travis.yml
    $dockerfile .= <<EOF;
ENV CI_BUILD_DIR /bbbike
WORKDIR bbbike

# "-e" -> init_travis must not be run anymore
# init_env_vars does not work in a Dockerbuild environment. Set some env vars manually
ENV CODENAME $real_distver
EOF

    # Apply --build-env
    for my $key (sort keys %{ $opt{'build-env'} }) {
	$dockerfile .= <<EOF;
ENV $key "$opt{'build-env'}->{$key}"
EOF
    }

    $dockerfile .= <<EOF;
RUN /bin/bash --login -e -c "wrapper init_perl"
RUN /bin/bash --login -e -c "wrapper init_apt"
RUN /bin/bash --login -e -c "wrapper install_non_perl_dependencies"
RUN /bin/bash --login -e -c "wrapper install_perl_testonly_dependencies"
RUN /bin/bash --login -e -c "wrapper install_old_perl_dependencies"
RUN /bin/bash --login -e -c "wrapper install_webserver_dependencies"
RUN /bin/bash --login -e -c "wrapper install_selenium"
RUN /bin/bash --login -e -c "wrapper install_perl_dependencies"
EOF

    $dockerfile .= _dockerfile_frag_src(\%opt);

    $dockerfile .= <<EOF;
RUN /bin/bash --login -e -c "wrapper init_cgi_config"
RUN /bin/bash --login -e -c "wrapper fix_cgis"
RUN /bin/bash --login -e -c "wrapper init_webserver_config"

ENV TRAVIS true
EOF

    # Apply the rest of --env
    for my $key (sort keys %{ $opt{env} }) {
	$dockerfile .= <<EOF;
ENV $key $opt{env}->{$key}
EOF
    }

    # Dependencies for data building
    if ($opt{'with-data-build'}) {
	my $pkwalify_distname;
	if (
	    ($real_dist eq 'debian' && $real_distver =~ m{^(squeeze|wheezy|jessie)$}) ||
	    ($real_dist eq 'ubuntu' && $real_distver =~ m{^(trusty)$})
	   ) {
	    $pkwalify_distname = 'libkwalify-perl'; # available in mydebs.bbbike.de
	} else {
	    $pkwalify_distname = 'pkwalify'; # available in official repos
	}
	$dockerfile .= <<EOF
RUN apt-get install -qqy \\
    libdata-compare-perl \\
    libdatetime-event-easter-perl \\
    libdatetime-event-recurrence-perl \\
    libdatetime-format-iso8601-perl \\
    $pkwalify_distname \\
    libyaml-syck-perl \\
    bmake
EOF
    }

    # Dependencies for test coverage
    if (defined $opt{'cover-dir'}) {
	$dockerfile .= <<EOF
RUN apt-get install -qqy \\
    libdevel-cover-perl
EOF
    }

    # XXX review and maybe remove again
    if ($real_distver =~ /bookworm/) {
	warning "Temporary hack: provide /etc/mapserver.conf until better solutions exist";
	$dockerfile .= <<'EOF';
RUN if [ "$BBBIKE_TEST_SKIP_MAPSERVER" != "1" ]; then cp /bbbike/mapserver/brb/mapserver.conf /etc; fi
EOF
    }

    # Start all services and finally run the test suite
    $dockerfile .= qq{CMD /bin/bash --login -e -c "wrapper start_webserver && wrapper start_xserver && wrapper init_webserver_environment && wrapper start_selenium && wrapper init_data && perl Makefile.PL && make distcheck && };
    if (defined $opt{'cover-dir'}) {
	$dockerfile .= qq{make ext coverage && used_config};
    } elsif (!$opt{'with-data-build'}) {
	$dockerfile .= qq{HARNESS_TIMER=1 make test HARNESS_OPTIONS=j$opt{jobs} && used_config};
    } else {
	# ... except in with-data-build mode; actual test will run later (see below)
	$dockerfile .= qq{while true; do sleep 3600; done};
    }
    $dockerfile .= qq{"\n};
    # "make test" should be last command --- check scripts may look at the end of the generated log
    ## End of Dockerfile building

    $doit->write_binary("$docker_context_dir/Dockerfile", $dockerfile);
    if ($opt{src} eq 'local') {
	$doit->mkdir("$docker_context_dir/bbbike");
	in_directory {
	    $doit->run(
		       ['git', 'ls-files', '-z'], '|',
		       ['rsync', '-a', '--files-from=-', '-0', '--no-dirs', '--whole-file', '.', "$docker_context_dir/bbbike"],
		      );
	} $bbbike_rootdir;
    } else {
	$doit->make_path("$docker_context_dir/bbbike/port/ci");
	$doit->copy("$bbbike_rootdir/port/ci/ci-functions.sh", "$docker_context_dir/bbbike/port/ci/");
	# mtime has to be preserved, otherwise older docker (<1.8?)
	# will take mtime into account when calculating cache checksums
	# see https://github.com/moby/moby/pull/12031
	my $mtime = (stat("$bbbike_rootdir/port/ci/ci-functions.sh"))[9];
	$doit->utime($mtime, $mtime, "$docker_context_dir/bbbike/port/ci/ci-functions.sh");
    }

    in_directory {
	my $scope_cleanups = Doit::ScopeCleanups->new;
	(my $tag_suffix = $image) =~ s{:}{-}g;
	my $tag = 'bbbike-ci-' . $tag_suffix;

	eval { $doit->system(qw(docker rmi), "$tag-old") };
	eval { $doit->system(qw(docker tag), $tag, "$tag-old") };
	_docker_build_with_retry($doit, $image, ['--tag', $tag, ($opt{'no-cache'} ? '--no-cache' : ()), '.']);

	eval { $doit->system(qw(docker rm), $tag) };

	my @errors;
	if (!$opt{'with-data-build'}) {
	    my @docker_cmd = (qw(docker run), ($opt{'keep-container'} ? () : qw(--rm)), qw(--name), $tag);
	    if (defined $opt{'cover-dir'}) {
		push @docker_cmd, '-v', $opt{'cover-dir'}.':/bbbike/cover_db';
	    }
	    push @docker_cmd, $tag;
	    eval {
		$doit->system(@docker_cmd);
	    };
	    if ($@) {
		push @errors, "docker run failed: $@";
	    }
	} else {
	    $doit->system(qw(docker run -d --name), $tag, $tag);

	    # in with-data-build mode two test suites run: code and data test
	    $scope_cleanups->add_scope_cleanup(sub { $doit->system(qw(docker kill), $tag) });
	    my @errors;

	    # XXX hmmm --- probably it would be a good idea to wait until the initial CMD was already done
	    eval {
		$doit->system(qw(docker exec), $tag, 'sh', '-c', 'cd data && bmake all slow-checks really-slow-checks');
	    };
	    if ($@) {
		push @errors, "data build errored: $@";
	    }

	    eval {
		$doit->system(qw(docker exec), $tag, qw(env HARNESS_TIMER=1 make test), "HARNESS_OPTIONS=j$opt{jobs}")
	    };
	    if ($@) {
		push @errors, "code test errored: $@";
	    }
	}

	if (!$doit->is_dry_run) {
	    my $t1 = Time::HiRes::time();
	    info sprintf "Run time: %.1fs", $t1-$t0;
	}

	{
	    my @test_note_cmd;
	    push @test_note_cmd, @errors ? '--fail' : '--pass';
	    push @test_note_cmd, '--docker';
	    push @test_note_cmd, '--spec', $image;
	    for my $key (sort keys %changed_env) {
		push @test_note_cmd, '--feature', $key.'='.$changed_env{$key};
	    }
	    if ($opt{'perl-ver'}) {
		push @test_note_cmd, '--feature', 'perl=' . $opt{'perl-ver'};
	    }
	    if (!$doit->is_dry_run) {
		info "Use the following as test note command:\n\tgit-test-note @test_note_cmd\n";
	    }
	}

	if (@errors) {
	    error "Tests failed:\n" . join("\n", @errors);
	}
    } $docker_context_dir;
}

sub build_deb {
    my($doit, %opt) = @_;
    lock_keys %opt;

    my($distfile, $distvname);
    if ($opt{distfile}) {
	$distfile = $opt{distfile};
	($distvname = basename($distfile)) =~ s{.tar.gz$}{};
    } else {
	require BBBikeBuildUtil;
	my $bsdmake = BBBikeBuildUtil::get_pmake(fallback => 0);

	if (!$opt{continue} || !-e "Makefile") {
	    $doit->system($^X, "Makefile.PL");
	}
	chomp($distvname = $doit->info_qx($bsdmake, "-VDISTVNAME"));
	$distfile = "$distvname.tar.gz";
	if (!$opt{continue} || !-s $distfile) {
	    $doit->system($bsdmake, "dist");
	}
    }
    if (!-s $distfile) {
	error "Expected distfile $distfile is missing";
    }
    my $distbasefile = basename $distfile;

    # Look into tarball for Debian version
    my $dist_tempdir = tempdir("bbbike_deb_XXXXXXXX", TMPDIR => 1, CLEANUP => 1);
    $doit->system("tar", "-C", $dist_tempdir, "-xf", $distfile, "$distvname/BBBikeVar.pm");
    require Safe;
    my $safe = Safe->new;
    $safe->rdo("$dist_tempdir/$distvname/BBBikeVar.pm");
    my $stable_version = $safe->reval('$BBBike::STABLE_VERSION');
    $stable_version or error "Can't get STABLE_VERSION";
    my $debian_version = $safe->reval('$BBBike::DEBIAN_VERSION');
    $debian_version or error "Can't get DEBIAN_VERSION";

    # Prepare docker environment
    my $docker_context_dir = tempdir("docker_context_XXXXXXXX", TMPDIR => 1, CLEANUP => 1);
    $doit->copy($distfile, $docker_context_dir);
    my $origfile = "bbbike_${stable_version}.orig.tar.gz";
    $doit->copy("$docker_context_dir/$distbasefile", "$docker_context_dir/$origfile"); # XXX why?
    $doit->system('rsync', '-a', 'port/debian/', "$docker_context_dir/debian/");
    my $debfile = "bbbike_${debian_version}_all.deb";

    my $dockerfile = <<EOF;
FROM $opt{dist}:$opt{distver}
EOF
    $dockerfile .= _dockerfile_invalidate_cache if $opt{'invalidate-apt'};
    $dockerfile .= <<EOF;
RUN apt-get update && apt-get install -qqy dpkg-dev lintian rsync debhelper
RUN mkdir /bbbike
COPY $distbasefile /bbbike
COPY $origfile /bbbike
COPY /debian/ /bbbike/debian/
WORKDIR /bbbike
RUN tar xf $distbasefile && cd $distvname && rsync -a ../debian/ debian/ && dpkg-buildpackage -us -uc -rfakeroot -D
RUN lintian $debfile
CMD /bbbike/debian/helper/install-deb ./$debfile && cp -f $debfile /hosttmp
EOF
    $doit->write_binary("$docker_context_dir/Dockerfile", $dockerfile);
    in_directory {
	my $tag = "bbbike-deb-$opt{dist}-$opt{distver}";
	$doit->system("docker", "build", "--tag", $tag, ".");
	$doit->system("docker", "run", "-v", "/tmp:/hosttmp", $tag);
	$doit->system("ls", "-al", "/tmp/$debfile");
    } $docker_context_dir;
}

sub cgi {
    my($doit, %opt) = @_;
    lock_keys %opt;

    my $pwd = save_pwd2;
    chdir bbbike_root or die "Can't chdir: $!";

    my $docker_port = 5000;

    my $use_bbbike_ppa;
    if (defined $opt{'use-bbbike-ppa'}) {
	$use_bbbike_ppa = $opt{'use-bbbike-ppa'};
    } elsif ($codename_to_packagerepos{$opt{'distver'}}->{'bbbike-ppa'}) {
	$use_bbbike_ppa = 1;
	info "bbbike-ppa support exists for $opt{dist}:$opt{distver} --- using it";
    }

    # Prepare docker environment
    my $docker_context_dir = tempdir("docker_context_XXXXXXXX", TMPDIR => 1, CLEANUP => 1);
    require ExtUtils::Manifest;
    ExtUtils::Manifest::manicopy(ExtUtils::Manifest::maniread(), $docker_context_dir, "cp");
    # Additional files needed not listed in MANIFEST
    for my $f ("cgi/GNUmakefile", "cgi/Makefile", "miscsrc/b2gmake") {
	$doit->copy("$FindBin::RealBin/../$f", "$docker_context_dir/" . dirname($f));
    }
    if ($opt{mapserver}) {
	# XXX Actually it would be easier to copy everything in the repository, not just the files mentioned in MANIFEST
	for my $f ("data/Makefile", "data/Makefile.mapfiles", "data/Makefile.garmin", "data/doit.pl", bsd_glob("data/*-orig"), "data/temp_blockings/bbbike-temp-blockings.pl", bsd_glob("data/temp_blockings/*.bbd"),  bsd_glob("miscsrc/*")) {
	    my($src, $dest) = ("$FindBin::RealBin/../$f", "$docker_context_dir/" . dirname($f));
	    next if -d $src; # ignore directories in miscsrc
	    $doit->copy($src, $dest);
	}
	for my $f ("miscsrc/bbbikedraw.pl", "miscsrc/bbd2esri") {
	    $doit->chmod(0755, "$docker_context_dir/$f"); # XXX copy should really preserve the file mode
	}
	$doit->system("cp", "-rf", "$FindBin::RealBin/../mapserver/", "$docker_context_dir/mapserver/");
    }

    my $dockerfile = <<EOF;
FROM $opt{dist}:$opt{distver}
EOF
    $dockerfile .= _dockerfile_invalidate_cache if $opt{'invalidate-apt'};
    $dockerfile .= _dockerfile_fix_sources_list(\%opt);
    $dockerfile .= _dockerfile_apt_auth(\%opt);

    my $fonts_dejavu_package = (
				(
				 ($opt{dist} eq 'ubuntu' && $opt{distver} =~ m{^(trusty|precise|xenial)$}) ||
				 ($opt{dist} eq 'debian' && $opt{distver} =~ 'wheezy')
				) ? 'ttf-dejavu' : 'fonts-dejavu'
			       );
    $dockerfile .= <<EOF;
ENV DEBIAN_FRONTEND noninteractive
RUN apt-get update && apt-get install -qqy --no-install-recommends \\
      libgd3 libgd-gd2-perl ttf-bitstream-vera $fonts_dejavu_package \\
      libpdf-create-perl libcairo-perl libpango-perl libfont-afm-perl \\
      libimager-perl libsvg-perl librsvg2-bin \\
      libstring-approx-perl libdbd-xbase-perl libxml-parser-perl \\
      libxml-twig-perl libdbi-perl libtie-ixhash-perl \\
      libobject-realize-later-perl libmldbm-perl \\
      libclass-accessor-perl libarchive-zip-perl \\
      libtemplate-perl libxml-libxml-perl libxml-simple-perl \\
      libyaml-libyaml-perl libjson-xs-perl \\
      libtext-unidecode-perl libdata-compare-perl \\
      libdate-calc-perl libdatetime-perl libimage-exiftool-perl \\
      libgeo-metar-perl libtext-csv-xs-perl libxml2-utils libdb-file-lock-perl \\
      libapache-session-perl libfile-counterfile-perl \\
      libdigest-md5-perl libmodule-metadata-perl libimager-qrcode-perl \\
      starman tzdata
RUN perl -i -pe 's/^(deb.*main)\$/\$1 contrib non-free/' /etc/apt/sources.list && apt-get update
RUN apt-get install -qqy --no-install-recommends \\
      agrep wget gnupg
EOF
    if ($use_bbbike_ppa) {
	$dockerfile .= <<EOF;
RUN apt-get install -qqy --no-install-recommends \\
      software-properties-common
RUN add-apt-repository ppa:eserte/bbbike
EOF
    } else {
	$dockerfile .= <<'EOF';
RUN wget -O- http://mydebs.bbbike.de/key/mydebs.bbbike.key | apt-key add -
RUN CODENAME=$(perl -nle '/^VERSION_CODENAME="?([^"]+)/ and $codename=$1; /^VERSION="\d+ \((.*)\)/ and $maybe_codename=$1; END { print $codename // $maybe_codename }' /etc/os-release); echo deb http://mydebs.bbbike.de ${CODENAME} main > /etc/apt/sources.list.d/mydebs.bbbike.list~ && mv /etc/apt/sources.list.d/mydebs.bbbike.list~ /etc/apt/sources.list.d/mydebs.bbbike.list
EOF
    }
    $dockerfile .= <<EOF;
RUN apt-get update && apt-get install -qqy --no-install-recommends \\
      libplack-middleware-rewrite-perl libcgi-emulate-psgi-perl libcgi-compile-perl \\
      libapache-session-counted-perl \\
      libarray-heap-perl \\
      make gcc libc6-dev libinline-perl libinline-c-perl \\
      libmime-lite-perl
EOF
    if ($opt{mapserver}) {
	$dockerfile .= <<EOF;
RUN apt-get install -qqy --no-install-recommends \\
      bmake mapserver-bin cgi-mapserver
EOF
    }
    $dockerfile .= <<EOF;
# XXX check the above list, and maybe minimize!
# XXX mapserver not included, because of complicated build process
RUN mkdir /bbbike
COPY . /bbbike
WORKDIR /bbbike
RUN perl Makefile.PL && make ext
EOF
    # next lines taken from init_cgi_config from ci-functions.sh
    if (!$opt{mapserver}) {
	$dockerfile .= <<'EOF';
RUN (cd cgi && ln -snf bbbike-debian-no-mapserver.cgi.config bbbike.cgi.config)
EOF
    } else {
	$dockerfile .= <<'EOF';
RUN (cd cgi && ln -snf bbbike-debian.cgi.config bbbike.cgi.config)
RUN (cd data && perl -I.. -MBBBikeBuildUtil=run_pmake -e 'run_pmake' mapfiles)
RUN (cd mapserver/brb && touch -t 197001010000 Makefile.local.inc && perl -I../.. -MBBBikeBuildUtil=run_pmake -e 'run_pmake')
EOF
	# XXX review and maybe remove again
	if ($opt{distver} =~ /bookworm/) {
	    warning "Temporary hack: provide /etc/mapserver.conf until better solutions exist";
	    $dockerfile .= <<'EOF';
RUN cp /bbbike/mapserver/brb/mapserver.conf /etc
EOF
	}
    }
    $dockerfile .= <<EOF;
WORKDIR /bbbike/cgi
RUN make symlinks fix-permissions
EXPOSE $docker_port
CMD starman --listen :$docker_port bbbike.psgi
EOF
    $doit->write_binary("$docker_context_dir/Dockerfile", $dockerfile);
    in_directory {
	my $tag = "bbbike-cgi-$opt{dist}-$opt{distver}";
	$doit->system("docker", "build", "--tag", $tag, ".");
	eval { $doit->system("docker", "rm", "-f", $tag) };
	my $docker_ppid = fork;
	die $! if !defined $docker_ppid;
	if ($docker_ppid == 0) {
	    $doit->system("docker", "run", "-it", "--name", $tag, "-P", $tag);
	    exit 0;
	}
	info "Waiting for container to obtain port (max. 30s) and for service beeing started";
	my $port;
    RETRY: for my $try (1..100) {
	    my $docker_port_res = eval { $doit->info_open3({quiet=>1,errref=>\my $stderr}, "docker", "port", $tag) };
	    if ($docker_port_res) {
		for my $line (split /\n/, $docker_port_res) {
		    if ($line =~ m{^$docker_port/tcp -> .*:(\d+)}) {
			$port = $1;
			last RETRY;
		    }
		}
	    }
	    Time::HiRes::sleep($try < 50 ? 0.1 : 0.5);
	    my $kid = waitpid($docker_ppid, WNOHANG);
	    if ($kid) {
		error "container exited prematurely --- \$?=$?";
	    }
	}
	if (!$port) {
	    warning "Cannot get container port";
	} else {
	    {
		my $initialized = 0;
		require HTTP::Tiny;
		my $ua = HTTP::Tiny->new;
	    RETRY: for my $try (1..10) {
		    my $resp = $ua->get("http://localhost:$port/bbbike/cgi/bbbike.cgi?init_environment=1");
		    if ($resp->{status} == 200) {
			$initialized = 1;
			last RETRY;
		    }
		    Time::HiRes::sleep(0.5);
		}
		if (!$initialized) {
		    warning "cgi environment could not be successfully initialized";
		}
	    }
	    if ($opt{test}) {
		local %ENV = %ENV;
		$doit->setenv(BBBIKE_TEST_SKIP_MAPSERVER => 1);
		$doit->setenv(BBBIKE_TEST_CGIDIR => "http://localhost:$port/bbbike/cgi");
		$doit->system('prove', "$FindBin::RealBin/../t/cgihead.t");
	    }
	    info "Access web service under http://localhost:$port";
	}
	info "Please CTRL-C or execute 'docker kill $tag' to stop container";
	waitpid($docker_ppid, 0);
    } $docker_context_dir;
}

return 1 if caller;

sub _check_distver ($) {
    my $distver = shift;
    if ($distver =~ m{^5\.\d+\.\d+-}) {
	# This looks like a perl:... image, accept it
	return;
    }
    if ($distver =~ m{^\d+}) {
	die "Use symbolic --distver (i.e. bionic instead of 18.04)\n";
    }
}

my $doit = Doit->init;

my $subcmd = shift
    or usage "Subcmd is missing.";

if ($subcmd =~ m{^(gui|perl[-_]?tk)$}) {
    my %opt = (
	       dist    => 'debian',
	       distver => 'latest',
	       src     => 'local',
	       branch  => undef,
	       debug   => 0,
	       'bbbike-args' => '',
	       'install-recommends' => 1,
	       'install-suggests' => 0,
	       'feature-pdf' => 1,
	       'feature-svg' => 1,
	       'feature-remote' => 1,
	       'invalidate-apt' => 0,
	       'docker-image' => undef,
	      );
    GetOptions(\%opt,
	       "dist=s",
	       "distver|distversion=s",
	       "src=s",
	       "branch=s",
	       'debug!',
	       'bbbike-args=s',
	       'install-recommends!',
	       'install-suggests!',
	       'feature-pdf!',
	       'feature-svg!',
	       'feature-remote!',
	       'invalidate-apt!',
	       'docker-image=s',
	      )
	or usage_gui;
    gui($doit, %opt);
} elsif ($subcmd eq 'ci' || $subcmd eq 'test') {
    my %opt = (
	       jobs    => 1,
	       dist    => 'debian',
	       distver => 'jessie',
	       src     => 'github',
	       branch  => undef,
	       env     => {},
	       'build-env' => {},
	       'with-data-build' => 0,
	       'no-cache' => 0,
	       'keep-container' => 0,
	       'invalidate-apt' => 0,
	       'perl-ver' => undef,
	       'image-variant' => undef,
	       'cover-dir' => undef,
	      );
    GetOptions(\%opt,
	       "jobs|j=i",
	       "dist=s",
	       "distver|distversion=s",
	       "src=s",
	       'branch=s',
	       'env=s%',
	       'build-env=s%',
	       "with-data-build!",
	       'no-cache',
	       'keep-container!',
	       'invalidate-apt!',
	       'perl-ver=s',
	       'image-variant=s',
	       'cover-dir=s',
	      )
	or usage_ci;
    _check_distver $opt{distver};
    ci($doit, %opt);
} elsif ($subcmd eq 'build-deb') {
    my %opt = (
	       dist    => 'debian',
	       distver => 'latest',
	       distfile => undef,
	       continue => 0,
	       'invalidate-apt' => 0,
	      );
    GetOptions(\%opt,
	       "dist=s",
	       "distver|distversion=s",
	       "distfile=s",
	       "continue!",
	       'invalidate-apt!',
	      )
	or usage_build_deb;
    build_deb($doit, %opt);
} elsif ($subcmd =~ m{^(cgi|web)$}) {
    my %opt = (
	       dist    => 'debian',
	       distver => 'jessie',
	       test => 0,
	       'invalidate-apt' => 0,
	       mapserver => 0,
	       'use-bbbike-ppa' => undef,
	      );
    GetOptions(\%opt,
	       "dist=s",
	       "distver|distversion=s",
	       "test!",
	       'invalidate-apt!',
	       'mapserver!',
	       'use-bbbike-ppa!',
	      )
	or usage_cgi;
    cgi($doit, %opt);
} else {
    usage "Unknown subcmd '$subcmd'";
}
__END__

=head1 NAME

docker-bbbike - run bbbike tasks in docker

=head1 SYNOPSIS

    ./miscsrc/docker-bbbike [options]

=head1 DESCRIPTION

C<docker-bbbike> may run different tasks in a docker environment, see below.

Before you start, a working docker environment and some other
prerequisites are needed. On a linux system, the following tasks
usually need to be done:

=over

=item * install docker and further dependencies

    sudo apt-get install docker.io libipc-perl-run

Fur running the C<docker-bbbike ci --src=local> subcommand the following are also needed:

    sudo apt-get install rsync git

=item * make sure you can run docker without C<sudo>

Add yourself to the C<docker> group, e.g. using

    sudo usermod -a -G docker $USER

After doing this, it is necessary to have a fresh shell --- either
logout and login again, or start a new shell.

=item * if you don't have the bbbike source code checked out at all, do the following (make sure that the C<git> package is installed)

    git clone --depth=1 https://github.com/eserte/bbbike && cd bbbike

Otherwise just C<cd> into the bbbike source directory.

=back

=head2 GUI

Run GUI application (also known as the BBBike Perl/Tk application) in
a docker image, forwarding display to the real X11 display:

    ./miscsrc/docker-bbbike gui

The same, but specify OS + version (instead of default debian:latest):

    ./miscsrc/docker-bbbike gui --dist ubuntu --distver 16.04

To start bbbike from an existing .deb package, use

    ./miscsrc/docker-bbbike gui --src /path/to/bbbike.deb

Supply bbbike options:

    ./miscsrc/docker-bbbike gui --bbbike-args="-lazy -advanced"

=head2 TESTS (like in github actions)

Run test suite like in github actions, with settings C<USE_MODPERL=1> and
C<USE_SYSTEM_PERL=1>:

    ./miscsrc/docker-bbbike ci --jobs 4

Instead of C<ci>, the alias C<test> may be used.

The same, but specify additional environment variables:

    ./miscsrc/docker-bbbike ci --jobs 4 --env BBBIKE_TEST_GUI=1

Use another Ubuntu version (default is trusty):

    ./miscsrc/docker-bbbike ci --jobs 4 --distver precise

Including Mapserver tests:

    ./miscsrc/docker-bbbike ci --jobs 4 --env BBBIKE_TEST_SKIP_MAPSERVER=0

Use another perl version, and don't use mod_perl, but starman instead:

    ./miscsrc/docker-bbbike ci --jobs 4 --env BBBIKE_TEST_SKIP_MODPERL=1 --env USE_MODPERL=0 --perl-ver 5.20.3

Don't use the current source from github, rather copy the current
source directory into the docker container:

    ./miscsrc/docker-bbbike ci --jobs 4 --src local

A crontab entry may look like this:

    48 0 * * *      mkdir -p $HOME/log/docker-bbbike-debian-jessie && cd $HOME/cvrsnica/src/bbbike && ./miscsrc/docker-bbbike test --dist debian --distver jessie --src local --env BBBIKE_TEST_SKIP_MAPSERVER=0 > $HOME/log/docker-bbbike-debian-jessie/$(date +\%FT\%T.log) 2>&1

Coverage testing may be activated using the C<--cover-dir> option
which needs to be set to a directory which contains the coverage
files, including F<coverage.html>:

    ./miscsrc/docker-bbbike ci --cover-dir /tmp/bbbike-cover_db
    firefox /tmp/bbbike-cover_db/coverage.html

=head2 DEB PACKAGE BUILD

Create a debian package for the current source:

    ./miscsrc/docker-bbbike build-deb

The resulting .deb file will be in F</tmp>.

To continue a partially completed run, use

    ./miscsrc/docker-bbbike build-deb --continue

This would especially skip the creation of the intermediate tarball.

The options C<--dist> and C<--distver> may be used to use another
Debian/Ubuntu/... version. The default is to use the latest Debian.

Create a debian package for an existing tarball:

    ./miscsrc/docker-bbbike build-deb --distfile BBBike-X.YY.tar.gz

=head2 CGI

Run the cgi in a docker container:

    ./miscrc/docker-bbbike cgi --distver jessie

=head1 SEE ALSO

L<docker(1)>.

=cut
