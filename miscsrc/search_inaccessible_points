#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: search_inaccessible_points,v 1.11 2008/11/07 22:46:32 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2001,2003,2004 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://bbbike.de
#

# This script will create a .bbd file of all inaccessible points for
# a given street net (in combination with gesperrt)

use FindBin;
use lib ("$FindBin::RealBin/..",
	 "$FindBin::RealBin/../lib",
	 "$FindBin::RealBin/../data",
	);
use Strassen;
use Getopt::Long;
use strict;

my $s;
my $blocked;
my $refpoint;
my $usecache;
my $v;
my $debug;
my $shorter;
my $encoding;
my $map;
my $stats;
my $max_loops = 10;

my @s_files;
my @blocked_files;
my @blocked_type;

my @allowed_blocked_type = qw(einbahn sperre tragen wegfuehrung);

if (!GetOptions("street=s@"  => sub { push @s_files, split /,/, $_[1] },
		"blocked=s@" => sub { push @blocked_files, split /,/, $_[1] },
		"blockedtype=s@" => \@blocked_type,
		"refpoint=s" => \$refpoint,
		"q" => sub { warn "-q option is obsolete" },
		"cache" => \$usecache,
		"v" => \$v,
		"debug" => \$debug,
		"shorter" => \$shorter,
		"encoding=s" => \$encoding,
		"stats!" => \$stats,
		"maxloops=i" => \$max_loops,
	       )) {
    die <<EOF;
usage: $0 [-street file] [-blocked file]
       [-blockedtype type] [-refpoint x,y] [-v] [-cache] [-shorter] [-stats]
       [-encoding encoding]
-street and -blocked may be given multiple times or separated with commas
-blockedtype may be given multiple times and should be one of
             @allowed_blocked_type
-shorter: just ouput the first street name for a blocking series
EOF
}

if (!$usecache) {
    eval 'use BBBikeXS';
    if ($@) {
	warn "Can't load BBBikeXS, expect slower operation or specify -cache.\n";
	if ($v) { warn $@ }
    }
}

if ($v) {
    Strassen::set_verbose($v);
}

if (!@s_files) { push @s_files, "strassen" }
if (!@blocked_files) { push @blocked_files, "gesperrt" }

# blocked types
if (!@blocked_type) { push @blocked_type, qw/einbahn sperre tragen/ }
my %blocked_type;
my $allowed_blocked_rx = join("|", @allowed_blocked_type);
foreach (@blocked_type) {
    if (/^($allowed_blocked_rx)$/) {
	$blocked_type{$_} = 1;
    } else {
	die "Only @allowed_blocked_type is allowed, not $_";
    }
}

$s = MultiStrassen->new(@s_files);
$blocked = MultiStrassen->new(@blocked_files);

{
    my $_encoding = $s->get_global_directive('encoding');
    $encoding = $_encoding if defined $_encoding;
}

{
    my $_map = $s->get_global_directive('map');
    $map = $_map if defined $_map;
}

my %carry_points;
$blocked->init;
while(1) {
    my $r = $blocked->next;
    last if !@{$r->[Strassen::COORDS]};
    next if $r->[Strassen::CAT] ne StrassenNetz::BLOCKED_CARRY;
    $carry_points{$r->[Strassen::COORDS][0]}++;
}

#old_search();
new_search();

sub old_search {
    if (!defined $refpoint) {
	# otherwise use first coordinate of first street as reference
	$refpoint = ($s->get(0))->[Strassen::COORDS][0];
    }

    my $net = StrassenNetz->new($s);
    $net->make_net(UseCache => $usecache);
    $net->make_sperre($blocked, %blocked_type);

    # loop over all points
    my $i = 0;
    $s->init;
    while(1) {
	my $r = $s->next;
	last if !@{$r->[Strassen::COORDS]};
	printf STDERR "%3d%%\r", (($i++)/@{$s->{Data}})*100;
	foreach my $c (@{$r->[Strassen::COORDS]}) {
	    next if $c eq $refpoint;
	    my(@r) = $net->search($c, $refpoint, AsObj => 1);
	    if ($r[0]->is_empty) {
		print "$r->[Strassen::NAME]\tX $c\n";
	    } else {
		# Simple optimization: use this point as the next refpoint
		# but only if it's not a "carry" point.
		if (!exists $carry_points{$c}) {
		    $refpoint = $c;
		}
	    }
	}
    }
}

sub new_search {
    my $net = StrassenNetz->new($s);
    $net->make_net(UseCache => $usecache);
    $net->make_sperre($blocked, %blocked_type);

    my $s = $net->{Strassen};

    my $number_unique_points = do {
	my %unique_points;
	$s->init;
	while() {
	    my $r = $s->next;
	    my @c = @{ $r->[Strassen::COORDS] };
	    last if !@c;
	    for my $c (@c) {
		$unique_points{$c} = 1;
	    }
	}
	scalar keys %unique_points;
    };

    my @islands;
    if ($refpoint) {
	push @islands, flood_search($net, $refpoint);
    } else {
	$s->init_for_iterator('refpoint');
	my %global_seen;
	my $flood_search_calls = 0;
    ITERATE_OVER_STREETS: while() {
	    my $r = $s->next_for_iterator('refpoint');
	    my @c = @{ $r->[Strassen::COORDS] };
	    last if !@c;

	    for my $c (@c) {
		if (!exists $global_seen{$c}) {
		    warn "flood search for refpoint=$c\n" if $debug;
		    my $island = flood_search($net, $c);
		    push @islands, $island;
		    while(my($k) = each %$island) {
			$global_seen{$k} = 1;
		    }
		    if ($debug) {
			warn "... found " . scalar(keys %$island) . " point(s) of total $number_unique_points in island\n";
			warn "global_seen has now " . scalar(keys %global_seen) . " entries\n";
		    }
		    if (scalar(keys %$island) >= $number_unique_points/2) {
			warn "This is large enough, exiting loop.\n" if $debug;
			last ITERATE_OVER_STREETS;
		    }
		    $flood_search_calls++;
		    if ($flood_search_calls > $max_loops) {
			last ITERATE_OVER_STREETS;
		    }
		}
	    }
	}
    }

    @islands = sort { scalar(keys %$b) <=> scalar(keys %$a) } @islands;

    if ($encoding) {
	print "#: #: -*- coding: $encoding -*-\n";
	print "#:encoding: $encoding\n";
	binmode STDOUT, ":encoding($encoding)";
    }
    if ($map) {
	print "#:map: $map\n";
    }
    print "#:title: inaccessible points\n";
    print "#:\n";
    print "# generated by $0\n";
    print "#\n";

    if (@islands >= 1) {
	my $continent = $islands[0];
	my %seen_point;
	$s->init;
	while() {
	    my $r = $s->next;
	    my @c = @{ $r->[Strassen::COORDS] };
	    last if !@c;

	    my $name_output = 0;
	    for my $c (@c) {
		if (!exists $continent->{$c} && !$seen_point{$c}) {
		    if (!$shorter || !$name_output || length $r->[Strassen::NAME] <= 3) {
			print $r->[Strassen::NAME];
			$name_output = 1;
		    } else {
			print q{-"-};
		    }
		    print "\tX $c\n";
		    $seen_point{$c} = 1;
		}
	    }
	}
    }

    if ($stats) {
	print STDERR "search_inaccessible_points stats\n";
	if (@islands == 0) {
	    print STDERR "no data records?!\n";
	} else {
	    my $percentage = sub {
		my $index = 0;;
		sprintf "%.1f", 100*scalar(keys %{$islands[$index]})/$number_unique_points;
	    };
	    my $get_refpoint = sub {
		my $index = 0;
		(keys %{$islands[$index]})[0];
	    };
	    my $count_inaccessible_points = sub {
		$number_unique_points - scalar(keys %{$islands[0]});
	    };
	    print STDERR <<EOF;
largest continent:     @{[ $percentage->() ]}%
  ref point:           @{[ $get_refpoint->() ]}
  inaccessible points: @{[ $count_inaccessible_points->() ]}
EOF
	}
    }
}

# XXX Here no handling of carry_points
sub flood_search {
    my($net, $act_coord) = @_;
    my $net_net = $net->{Net};

    my($start_x,$start_y) = split /,/, $act_coord;

    my %CLOSED;
    my %OPEN;
    my %PRED;

    my $act_dist = 0;
    $OPEN{$act_coord} = $act_dist;
    $PRED{$act_coord} = undef;

    while (1) {
	$CLOSED{$act_coord} = $act_dist;
	delete $OPEN{$act_coord};

	while (my($neighbor, $dist) = each %{ $net_net->{$act_coord} }) {
	    next if exists $CLOSED{$neighbor} && $CLOSED{$neighbor} <= $act_dist + $dist;
	    $OPEN{$neighbor} = $act_dist + $dist;
	    $PRED{$neighbor} = $act_coord;
	}

	my $new_act_coord;
	my $new_act_dist = 99999999;
	while (my($c, $dist) = each %OPEN) {
	    if ($dist < $new_act_dist) {
		$new_act_coord = $c;
		$new_act_dist = $dist;
	    }
	}
	if (!defined $new_act_coord) {
	    #warn "Nothing more...";
	    last;
	}

	$act_coord = $new_act_coord;
	$act_dist = $new_act_dist;
	# warn $act_dist;
    }

    return \%CLOSED;
}

__END__
