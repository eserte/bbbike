#!/usr/bin/perl -w
#
# Copyright 2005 iconmobile GmbH. All rights reserved.
#

use strict;
our $VERSION = sprintf("%d.%02d", q$Revision: 1.22 $ =~ /(\d+)\.(\d+)/);

use File::Spec;
use File::Basename;
use Getopt::Long;
eval 'use Image::Info qw(image_info);';
use Image::ExifTool qw(ImageInfo);
eval 'use Digest::MD5 qw(md5_hex);';
use Time::Local qw(timelocal);
use GD;
use DB_File;
use FindBin;

use lib "$FindBin::RealBin/..";
use GPS::GpsmanData;
use Karte::Standard;
use Karte::Polar;
use BBBikeUtil qw(s2hm);

my $gps_data_dir = "$FindBin::RealBin/../misc/gps_data";
my $thumbnail_dir = "/tmp/thumbnails";
my $clock_gps;
my $clock_camera;
my $anchor;
my $thumbnail_size = 50;
my $converter = "best";
my $recreate_thumbnails;
my $date_index_file;
my $date_db;
my $v;
my $relative_paths;

sub usage (;$) {
    my $msg = shift;
    warn "$msg\n" if $msg;
    die <<EOF;
usage: $0
          [-gpsdatadir directory] [-thumbnaildir directory]
          [-clockgps HH:MM:SS -clockcamera HH:MM:SS]
	  [-anchor nw|n|ne|e|se|s|sw] [-thumbnailsize pixels]
          [-converter Image::GD::Thumbnail|ImageMagick|ImageMagick+exiftool|best|fast]
	  [-recreatethumbnails] [-rel|-relativepaths]
          [-v] image ...
EOF
}

GetOptions("gpsdatadir=s" => \$gps_data_dir,
	   "dateindex=s" => \$date_index_file,
	   "thumbnaildir=s" => \$thumbnail_dir,
	   "clockgps=s" => \$clock_gps,
	   "clockcamera=s" => \$clock_camera,
	   "anchor=s" => \$anchor,
	   "thumbnailsize=i" => \$thumbnail_size,
	   "converter=s" => \$converter,
	   "recreatethumbnails" => \$recreate_thumbnails,
	   "rel|relativepaths!" => \$relative_paths,
	   "v!" => \$v,
	  ) or usage;

my @images = @ARGV;
if (!@images) {
    usage "Please specify at least one image";
}

mkdir $thumbnail_dir if !-d $thumbnail_dir;
if (!-d $thumbnail_dir) {
    die "Cannot create thumbnail directory <$thumbnail_dir>: $!";
}

my $cam_delta = 0;
if ($clock_gps || $clock_camera) {
    for my $check ([\$clock_gps,    "-clockgps"],
		   [\$clock_camera, "-clockcamera"],
		  ) {
	my($varref, $opt) = @$check;
	if ($$varref !~ m{^\d{1,2}:\d{2}(:\d{2})?}) {
	    die "$opt must be in format HH:MM or HH:MM:SS";
	}
    }
    my($gps_H, $gps_M, $gps_S) = split /:/, $clock_gps;
    my($cam_H, $cam_M, $cam_S) = split /:/, $clock_camera;
    my $gps_seconds = $gps_H*60*60 + $gps_M*60 + ($gps_S||0);
    my $cam_seconds = $cam_H*60*60 + $cam_M*60 + ($cam_S||0);
    $cam_delta = $cam_seconds - $gps_seconds;
}

my @converter;
if ($converter eq 'best') {
    push @converter, 'ImageMagick', 'ImageMagick+exiftool', 'Image::GD::Thumbnail';
} elsif ($converter eq 'fast') {
    push @converter, 'ImageMagick+exiftool', 'Image::GD::Thumbnail', 'ImageMagick';
} elsif ($converter eq 'veryfast') {
    push @converter, 'Image::GD::Thumbnail', 'ImageMagick+exiftool', 'ImageMagick';
} else {
    @converter = $converter;
}
for my $try_converter (@converter) {
    if ($try_converter eq 'Image::GD::Thumbnail') {
	if (eval { require Image::GD::Thumbnail; 1 }) {
	    $converter = $try_converter;
	    last;
	}
    } elsif ($try_converter eq 'ImageMagick') {
	if (is_in_path("convert")) {
	    $converter = $try_converter;
	    last;
	}
    } elsif ($try_converter eq 'ImageMagick+exiftool') {
	if (is_in_path("convert") && is_in_path("exiftool")) {
	    $converter = $try_converter;
	    last;
	}
    } else {
	die "Unknown converter <$try_converter>";
    }
}
if (!$converter) {
    die "Can't use any converter from @converter";
}

sub get_image_location {
    my $file = shift;

    my($y,$m,$d,$H,$M,$S);

    if (defined &ImageInfo) {
	my $exif = ImageInfo($file);
	if ($exif) {
	    my $date = $exif->{DateTimeOriginal} || $exif->{CreateDate};
	    if (defined $date && $date =~ /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})/) {
		($y,$m,$d,$H,$M,$S) = ($1,$2,$3,$4,$5,$6);
	    }
	}
    }

    if (!defined $y && defined &image_info) {
	# Nokia 7650 hack
	my $info = image_info($file);
	if (my $error = $info->{error}) {
	    warn "Can't parse image info from $file: $error\n";
	    return;
	}

	if (defined $info->{Comment}) {
	    my(@lines) = split /\n/, $info->{Comment};
	    my $date = $lines[2];
	    my $time = $lines[3];

	    if (!defined $date || $date !~ m{^(\d+)[/-](\d+)[/-](\d{4})$}) {
		local $^W = 0;
		warn "Can't parse date <$date> in file <$file>, cannot geolocate, skipping...\n";
		return;
	    }
	    ($y,$m,$d) = ($3,$2,$1);

	    if (!defined $date || $time !~ m{^(\d+)[:\.](\d+)[:\.](\d+)$}) {
		local $^W = 0;
		warn "Can't parse time <$time> in file <$file>, cannot geolocate, skipping...\n";
		return;
	    }
	    ($H,$M,$S) = ($1,$2,$3);
	}
    }

    if (!defined $y) {
	warn "Cannot get date from image <$file>, skipping...\n"
	    if $v;
	return;
    }

    my $epoch = timelocal($S,$M,$H,$d,$m-1,$y-1900);
    $epoch -= $cam_delta;
    my @l = localtime $epoch;
    ($S,$M,$H,$d,$m,$y) = @l;
    $y+=1900;
    $m++;

    my $iso_date = sprintf "%04d-%02d-%02dT%02d:%02d:%02d", $y,$m,$d,$H,$M,$S;
    my $iso_date2 = sprintf "%04d-%02d-%02dT%02d%02d%02d", $y,$m,$d,$H,$M,$S;

    if ($date_db) {
	my($key, $val) = ($iso_date2, "");
	my $st = $date_db->seq($key, $val, R_CURSOR);
	my $used;
	if ($st == 0) {
	    if (my($fy,$fm,$fd,$fH,$fM,$fS) = $key =~ m{^(\d+)-(\d+)-(\d+)T(\d{2})(\d{2})(\d{2})}) {
		my $got_epoch = timelocal($fS,$fM,$fH,$fd,$fm-1,$fy-1900);
		my $interval = abs($got_epoch - $epoch);
		my(@fields) = split / /, $val;
		$used = "next";

		# got previous
		$st = $date_db->seq($key, $val, R_PREV);
		if ($st == 0) {
		    if (my($py,$pm,$pd,$pH,$pM,$pS) = $key =~ m{^(\d+)-(\d+)-(\d+)T(\d{2})(\d{2})(\d{2})}) {
			my $got_prev_epoch = timelocal($pS,$pM,$pH,$pd,$pm-1,$py-1900);
			my $prev_interval = abs($got_prev_epoch - $epoch);
			if ($prev_interval < $interval) {
			    # prefer previous
			    (@fields) = split / /, $val;
			    $interval = $prev_interval;
			    $used = "prev";
			}
		    }
		}

		if ($interval <= 180) {
		    my $ret = { Longitude => $fields[1],
				Latitude  => $fields[2],
				Interval => $interval,
				Waypoint => undef, # !
				Date     => $iso_date,
				Used     => $used,
			      };
		    return $ret;
		}
	    }
	}
	warn "Can't find $iso_date2 in DB, use fallback...\n";
    }

    my $isodate1 = sprintf("%04d%02d%02d", $y,$m,$d);
    my $isodate2 = sprintf("%04d-%02d-%02d", $y,$m,$d);

    my @filenames = map { $gps_data_dir . "/" . $_ } ("$isodate1.trk", "$isodate2.trk");

    my $filename;
    for my $check_filename (@filenames) {
	warn "Try $check_filename for date $iso_date...\n"
	    if $v;
	if (-e $check_filename) {
	    $filename = $check_filename;
	    last;
	}
    }

    if (!$filename) {
	for my $check_filename (glob("$gps_data_dir/*$isodate1*.trk"),
				glob("$gps_data_dir/*$isodate1*.track*"),
				glob("$gps_data_dir/*$isodate2*.trk"),
				glob("$gps_data_dir/*$isodate2*.track*"),
			       ) {
	    warn "Try $check_filename (via globbing)...\n"
		if $v;
	    if (-e $check_filename) { # should never fail
		$filename = $check_filename;
		last;
	    }
	}
    }

    if ($filename) {
	my $gps = GPS::GpsmanData->new;
	$gps->load($filename);
	my $got_wpt;
	my $last_wpt;
	my $interval;
	for my $wpt (@{ $gps->Track }) {
	    my $wpt_epoch = $wpt->Comment_to_unixtime($gps);
	    if ($wpt_epoch > $epoch) {
		if ($last_wpt &&
		    abs($last_wpt->Comment_to_unixtime($gps) - $epoch) <
		    abs($wpt_epoch - $epoch)) {
		    $got_wpt = $last_wpt;
		} else {
		    $got_wpt = $wpt;
		}
		last;
	    }
	    $last_wpt = $wpt;
	}
	if (!$got_wpt) {
	    $got_wpt = $gps->Track->[-1];
	}
	$interval = abs($got_wpt->Comment_to_unixtime($gps) - $epoch);
	if ($got_wpt) {
	    return { Latitude  => $got_wpt->Latitude,
		     Longitude => $got_wpt->Longitude,
		     Interval  => $interval,
		     Waypoint  => $got_wpt,
		     Date      => $iso_date,
		   };
	}
    }
    undef;
}

if ($date_index_file) {
    $date_db = tie my %db, 'DB_File', $date_index_file, O_RDONLY, 0644, $DB_BTREE
	or die "Can't tie $date_index_file: $!";
    
}

for my $file (@images) {
    if (-d $file) {
	require File::Find;
	my @files;
	File::Find::find(sub {
			     if (-f $_ && -r $_) {
				 push @files, $File::Find::name;
			     }
			 }, $file);
	for my $file (@files) {
	    handle_file($file);
	}
    } else {
	handle_file($file);
    }
}

sub handle_file {
    my $file = shift;
    my $ret = get_image_location($file);
    if (defined $ret) {
	my($lat, $long, $interval, $date) = @{$ret}{qw(Latitude Longitude Interval Date)};
	my($x, $y) = $Karte::Standard::obj->trim_accuracy
	    ($Karte::Polar::obj->map2standard($long, $lat));
	my $file_in_bbd = $relative_paths ? $file : File::Spec->rel2abs($file);
	my $thumb_file = create_thumbnail($file);
	if ($relative_paths) {
	    $thumb_file = File::Spec->abs2rel($thumb_file);
	}
	if (defined $thumb_file) {
	    my $interval_hm = s2hm($interval);
	    print qq{Image: "$file_in_bbd" ($date) (delta=$interval_hm) ($lat/$long)\tIMG:$thumb_file};
	    if ($anchor) {
		print qq{|ANCHOR:$anchor};
	    }
	    print qq{ $x,$y\n};
	}
    }
}

sub create_thumbnail {
    my $file = shift;

    # Save your thumbnail
    my $dest;
    if (defined &md5_hex) {
	my($ext) = $file =~ /(\.[^\.]+)$/;
	$ext = "" if !defined $ext;
	$dest = $thumbnail_dir . "/" . md5_hex($file) . $ext;
    } else {
	$dest = $thumbnail_dir . "/" . basename($file);
    }

    return $dest if (-r $dest && !$recreate_thumbnails);

    warn "Create thumbnail for $file...\n" if $v;

    if ($converter eq 'Image::GD::Thumbnail') {
	return create_thumbnail_Image_GD_Thumbnail($file, $dest);
    } elsif ($converter eq 'ImageMagick') {
	return create_thumbnail_ImageMagick($file, $dest);
    } elsif ($converter eq 'ImageMagick+exiftool') {
	return create_thumbnail_ImageMagick_exiftool($file, $dest);
    } else {
	die "Unknown converter $converter";
    }
}

sub create_thumbnail_Image_GD_Thumbnail {
    my($file, $dest) = @_;
    my ($thumb,$x,$y);
    eval {
	open my $IN, $file or die "Could not open $file: $!";
	binmode $IN;
	my $srcImage = GD::Image->new($IN);
	close $IN;
	
	($thumb,$x,$y) = Image::GD::Thumbnail::create($srcImage,$thumbnail_size);
    };
    if ($@) {
	warn $@;
	return undef;
    } else {
	open my $OUT, ">", $dest or die "Could not save $dest: $!";
	binmode $OUT;
	print $OUT $thumb->jpeg;
	close $OUT;
	return $dest;
    }
}

sub create_thumbnail_ImageMagick_exiftool {
    my($file, $dest) = @_;
    require File::Temp;
    my(undef,$smallfile) = File::Temp::tempfile(SUFFIX => "_geocode_images.jpg", UNLINK => 1);
    my $cmd = "exiftool -ThumbnailImage -b $file > $smallfile";
    warn "$cmd\n" if $v;
    system($cmd);
    if ($? != 0 || -z $smallfile) {
	my $cmd = "exiftool -PreviewImage -b $file > $smallfile";
	warn "$cmd\n" if $v;
	system($cmd);
	if ($? != 0 || -z $smallfile) {
	    $smallfile = $file;
	}
    }
    create_thumbnail_ImageMagick($smallfile, $dest);
    # XXX TODO: remove EXIF from thumbnail, otherwise it's huge!
}

sub create_thumbnail_ImageMagick {
    my($file, $dest) = @_;
    my @cmd = ("convert", "-quality", 70, "-resize", $thumbnail_size ."x". $thumbnail_size, $file, $dest);
    warn "@cmd\n" if $v;
    system @cmd;
    if ($? != 0 || -z $dest) {
	warn "@cmd failed: $?";
	return undef;
    } else {
	return $dest;
    }
}

# REPO BEGIN
# REPO NAME is_in_path /home/e/eserte/work/srezic-repository 
# REPO MD5 81c0124cc2f424c6acc9713c27b9a484
sub is_in_path {
    my($prog) = @_;
    return $prog if (file_name_is_absolute($prog) and -f $prog and -x $prog);
    require Config;
    my $sep = $Config::Config{'path_sep'} || ':';
    foreach (split(/$sep/o, $ENV{PATH})) {
	if ($^O eq 'MSWin32') {
	    # maybe use $ENV{PATHEXT} like maybe_command in ExtUtils/MM_Win32.pm?
	    return "$_\\$prog"
		if (-x "$_\\$prog.bat" ||
		    -x "$_\\$prog.com" ||
		    -x "$_\\$prog.exe" ||
		    -x "$_\\$prog.cmd");
	} else {
	    return "$_/$prog" if (-x "$_/$prog" && !-d "$_/$prog");
	}
    }
    undef;
}
# REPO END

# REPO BEGIN
# REPO NAME file_name_is_absolute /home/e/eserte/work/srezic-repository 
# REPO MD5 89d0fdf16d11771f0f6e82c7d0ebf3a8
BEGIN {
    if (eval { require File::Spec; defined &File::Spec::file_name_is_absolute }) {
	*file_name_is_absolute = \&File::Spec::file_name_is_absolute;
    } else {
	*file_name_is_absolute = sub {
	    my $file = shift;
	    my $r;
	    if ($^O eq 'MSWin32') {
		$r = ($file =~ m;^([a-z]:(/|\\)|\\\\|//);i);
	    } else {
		$r = ($file =~ m|^/|);
	    }
	    $r;
	};
    }
}
# REPO END

__END__

=head1 NAME

geocode_images - geocode images against a gps track data base

=head1 SYNOPSIS

See L</EXAMPLES>

=head1 DESCRIPTION

With geocode_images it is possible to create a connection between exif
coded images and a database of GPS tracks. The connection is done
through the date.

For now, it is assumed that the GPS track database is just a directory
with GPSMAN track files, where filenames are named I<YYYYMMDD.trk> or
I<YYYY-MM-DD.trk>.

=head1 EXAMPLES

    find ~/images/scans/Baltikum-02/baltics-bestof/ -name "*.jpg" -print0 | xargs -0 ~/src/bbbike/miscsrc/geocode_images -v -gpsdatadir ~/src/bbbike/misc/gps_data/polen_baltikum/ > /tmp/5.bbd

    cd ~/images/from_handy/Fotos/ && find . -name "*.jpg" -print0 | xargs -0 ~/src/bbbike/miscsrc/geocode_images > /tmp/1.bbd

Or put instructions in a makefile:

    geocode-rj1:
	mkdir -p rj-fotos/.xvpics
	$(HOME)/src/bbbike/miscsrc/geocode_images \
	    -gpsdatadir $(HOME)/src/bbbike/misc/gps_data/other \
	    -thumbnaildir rj-fotos/.xvpics \
	    -converter fast \
	    -clockgps 08:52:02 -clockcamera 08:49:43 \
	    -v -anchor nw -relativepaths \
	    rj-fotos/*.jpg > rj-fotos.bbd

B<-relativepaths> assumes that thumbnaildir, the specified photos and
the generated bbd file are relative to each other.

The B<-dateindex I</tmp/gpsdateindex.db>> option assumes that a GPS
index was build before with L<create_track_index.pl>.

=head1 HOWTO

To display geocoded thumbnails in bbbike:

=over

=item * Start bbbike

=item * Load the BBBikeViewImages plugin through "Plugin laden". The
plugin is located in the F<miscsrc> subdirectory of bbbike.

=item * Create a bbd file like explained in L</EXAMPLES>.

=item * Load the bbd file in bbbike: Zus‰tzlich zeichnen > Straﬂen-Layer zeichnen

=item * If necessary, then adjust the scrollregion (in the same menu)

=item * If the plugin was loaded, then it is possible to click on the
thumbnails to get the larger version

=back

=head1 SEE ALSO

L<create_track_index.pl>

=cut
