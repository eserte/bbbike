#!/usr/bin/perl -w
#
# Copyright (C) 2005-2008,2010 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
our $VERSION = 1.30;

use Cwd qw(realpath);
use File::Spec;
use File::Basename;
use Getopt::Long;
eval 'use Image::Info qw(image_info);';
use Image::ExifTool qw(ImageInfo);
eval 'use Digest::MD5 qw(md5_hex);';
use Time::Local qw(timelocal);
use GD;
use DB_File;
use FindBin;

use lib "$FindBin::RealBin/..";
use GPS::GpsmanData;
use Karte::Standard;
use Karte::Polar;
use BBBikeUtil qw(s2hm);

my $gps_data_dir = "$FindBin::RealBin/../misc/gps_data";
my $no_gps_data_dir;
my $thumbnail_dir = "/tmp/thumbnails";
my $clock_gps;
my $clock_camera;
my $clock_adjust_file;
my $anchor;
my $thumbnail_size = 50;
my $converter = "best";
my $recreate_thumbnails;
my $date_index_file;
my $date_db;
my $v;
my $debug;
my $relative_paths;
my $out_file;
my $max_delta = 180;

my $lax_iso_date_qr = qr{^(\d{4})\D*(\d{2})\D*(\d{2})T(\d{2})\D(\d{2})\D(\d{2})};
my $clock_qr        = qr{^\d{1,2}:\d{2}(:\d{2})?};

my $current_info = 'BEGIN';
{
    no warnings 'signal'; # INFO is usually only available on BSD systems
    $SIG{INFO} = sub {
	print STDERR $current_info, "\n";
	require Carp; Carp::carp('Currently');
    };
}

sub usage (;$) {
    my $msg = shift;
    warn "$msg\n" if $msg;
    die <<EOF;
usage: $0
          [-gpsdatadir directory | -nogpsdatadir] [-thumbnaildir directory]
	  [-clockadjustfile file | -clockgps HH:MM:SS -clockcamera HH:MM:SS]
	  [-anchor nw|n|ne|e|se|s|sw] [-thumbnailsize pixels]
          [-converter Image::GD::Thumbnail|ImageMagick|ImageMagick+exiftool|best|fast]
	  [-recreatethumbnails] [-rel|-relativepaths] [-o file]
          [-v] [-debug] image ...
EOF
}

GetOptions("gpsdatadir=s" => \$gps_data_dir,
	   "nogpsdatadir" => \$no_gps_data_dir,
	   "dateindex=s" => \$date_index_file,
	   "thumbnaildir=s" => \$thumbnail_dir,
	   "clockgps=s" => \$clock_gps,
	   "clockcamera=s" => \$clock_camera,
	   "clockadjustfile=s" => \$clock_adjust_file,
	   "anchor=s" => \$anchor,
	   "thumbnailsize=i" => \$thumbnail_size,
	   "converter=s" => \$converter,
	   "recreatethumbnails" => \$recreate_thumbnails,
	   "rel|relativepaths!" => \$relative_paths,
	   "o=s" => \$out_file,
	   "v!" => \$v,
	   "debug" => \$debug,
	  ) or usage;

undef $gps_data_dir if $no_gps_data_dir;

my @images = @ARGV;
if (!@images) {
    usage "Please specify at least one image";
}

mkdir $thumbnail_dir if !-d $thumbnail_dir;
if (!-d $thumbnail_dir) {
    die "Cannot create thumbnail directory <$thumbnail_dir>: $!";
}

my @cam_delta_mapping;
if ($clock_adjust_file) {
    undef $clock_gps;
    undef $clock_camera;
    open my $fh, $clock_adjust_file
	or die "Can't open file $clock_adjust_file: $!";
    while(<$fh>) {
	chomp;
	next if m{^\s*\#};
	next if m{^\s*$};
	my(@fields) = split /\s+/;
	if (@fields != 3 && @fields != 4) {
	    die <<EOF;
Cannot parse line '$_' in $clock_adjust_file, must be either

    isodate gpstime cameratime

or

    isodatetimefrom isodatetimeto gpstime cameratime
EOF
	}
	my($from, $to, $gps, $camera);
	if (@fields == 3) {
	    $from = $fields[0] . 'T00:00:00';
	    $to   = $fields[0] . 'T23:59:59';
	    ($gps, $camera) = @fields[1,2];
	} else {
	    ($from, $to, $gps, $camera) = @fields;
	}
	my $from_epoch = do {
	    my($Y,$M,$D,$h,$m,$s) = $from =~ $lax_iso_date_qr
		or die "Cannot parse date '$from' as ISO date";
	    timelocal($s,$m,$h,$D,$M-1,$Y-1900);
	};
	my $to_epoch = do {
	    my($Y,$M,$D,$h,$m,$s) = $to   =~ $lax_iso_date_qr
		or die "Cannot parse date '$to' as ISO date";
	    timelocal($s,$m,$h,$D,$M-1,$Y-1900);
	};
	push @cam_delta_mapping, [$from_epoch, $to_epoch, get_cam_delta($gps, $camera)];
    }
}

my $cam_delta = 0;
if ($clock_gps || $clock_camera) {
    for my $check ([\$clock_gps,    "-clockgps"],
		   [\$clock_camera, "-clockcamera"],
		  ) {
	my($varref, $opt) = @$check;
	if ($$varref !~ $clock_qr) {
	    die "$opt must be in format HH:MM or HH:MM:SS";
	}
    }
    $cam_delta = get_cam_delta($clock_gps, $clock_camera);
}

my @converter;
if ($converter eq 'best') {
    push @converter, 'ImageMagick', 'ImageMagick+exiftool', 'Image::GD::Thumbnail';
} elsif ($converter eq 'fast') {
    push @converter, 'ImageMagick+exiftool', 'Image::GD::Thumbnail', 'ImageMagick';
} elsif ($converter eq 'veryfast') {
    push @converter, 'Image::GD::Thumbnail', 'ImageMagick+exiftool', 'ImageMagick';
} else {
    @converter = $converter;
}
for my $try_converter (@converter) {
    if ($try_converter eq 'Image::GD::Thumbnail') {
	if (eval { require Image::GD::Thumbnail; 1 }) {
	    $converter = $try_converter;
	    last;
	}
    } elsif ($try_converter eq 'ImageMagick') {
	if (is_in_path("convert")) {
	    $converter = $try_converter;
	    last;
	}
    } elsif ($try_converter eq 'ImageMagick+exiftool') {
	if (is_in_path("convert") && is_in_path("exiftool")) {
	    $converter = $try_converter;
	    last;
	}
    } else {
	die "Unknown converter <$try_converter>";
    }
}
if (!$converter) {
    die "Can't use any converter from @converter";
}
if ($v) {
    print STDERR "The converter '$converter' will be used.\n";
}

sub get_image_location {
    my $file = shift;

    my($y,$m,$d,$H,$M,$S);

    if (defined &ImageInfo) {
	my $exif = ImageInfo($file);
	if ($exif) {

	    # Prefer GPS position recorded in EXIF:
	    my($lat_deg, $lat_min, $lat_sec, $lat_ref, $lon_deg, $lon_min, $lon_sec, $lon_ref);
	    my $polar_qr = qr{(\d+)\s+deg\s+(\d+)\'\s+([\d\.]+)\"};
	FIND_GPS_POS: {
		if ($exif->{GPSPosition}) {
		    if (($lat_deg, $lat_min, $lat_sec, $lat_ref, $lon_deg, $lon_min, $lon_sec, $lon_ref) =
			$exif->{GPSPosition} =~ m{
						  ^
						  $polar_qr\s+([NS]),\s*
						  $polar_qr\s+([EW])
					      }x) {
			$lat_deg *= -1 if $lat_ref =~ m{s}i;
			$lon_deg *= -1 if $lon_ref =~ m{w}i;
		    } else {
			warn "Cannot parse GPSPosition <$exif->{GPSPosition}>";
			last FIND_GPS_POS;
		    }
		} elsif ($exif->{GPSLatitude} && $exif->{GPSLongitude} &&
		    $exif->{GPSLatitudeRef} && $exif->{GPSLongitudeRef}) {
		    if (!(($lat_deg, $lat_min, $lat_sec) = $exif->{GPSLatitude} =~ $polar_qr)) {
			warn "Cannot parse GPSLatitude <$exif->{GPSLatitude}>";
			last FIND_GPS_POS;
		    }
		    if (!(($lon_deg, $lon_min, $lon_sec) = $exif->{GPSLongitude} =~ $polar_qr)) {
			warn "Cannot parse GPSLongitude <$exif->{GPSLongitude}>";
			last FIND_GPS_POS;
		    }
		    $lat_deg *= -1 if $exif->{GPSLatitudeRef} =~ m{^s}i;
		    $lon_deg *= -1 if $exif->{GPSLongitudeRef} =~ m{^w}i;
		} else {
		    last FIND_GPS_POS;
		}
		my $lat = Karte::Polar::dms2ddd($lat_deg, $lat_min, $lat_sec);
		my $lon = Karte::Polar::dms2ddd($lon_deg, $lon_min, $lon_sec);
		my $iso_date = $exif->{DateTimeOriginal} || $exif->{CreateDate}; # XXX GPSDateTime is nonsense in the N95
		$iso_date =~ s{ }{T}; # -> iso date sep
		my $ret = { Longitude => $lon,
			    Latitude  => $lat,
			    Delta    => 0,
			    Waypoint => undef, # ? XXX
			    Date     => $iso_date,
			    Used     => "exact",
			  };
		return $ret;
	    }

	    my $date = $exif->{DateTimeOriginal} || $exif->{CreateDate};
	    if (defined $date && $date =~ /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})/) {
		($y,$m,$d,$H,$M,$S) = ($1,$2,$3,$4,$5,$6);
	    }
	}
    }

    return if !defined $gps_data_dir;

    if (!defined $y && defined &image_info) {
	# Nokia 7650 hack
	my $info = image_info($file);
	if (my $error = $info->{error}) {
	    if ($file =~ m{(?:^|/)\.(?:xvpics|thumbs)/}) {
		# expected error, be quiet
	    } else {
		warn "Can't parse image info from $file: $error\n";
	    }
	    return;
	}

	if (defined $info->{Comment}) {
	    my(@lines) = split /\n/, $info->{Comment};
	    my $date = $lines[2];
	    my $time = $lines[3];

	    if (!defined $date || $date !~ m{^(\d+)[/.-](\d+)[/.-](\d{4})$}) {
		local $^W = 0;
		warn "Can't parse date <$date> in file <$file>, cannot geolocate, skipping...\n";
		return;
	    }
	    ($y,$m,$d) = ($3,$2,$1);

	    if (!defined $date || $time !~ m{^(\d+)[:\.](\d+)[:\.](\d+)$}) {
		local $^W = 0;
		warn "Can't parse time <$time> in file <$file>, cannot geolocate, skipping...\n";
		return;
	    }
	    ($H,$M,$S) = ($1,$2,$3);
	}
    }

    if (!defined $y) {
	warn "Cannot get date from image <$file>, skipping...\n"
	    if $v;
	return;
    }

    my $epoch = timelocal($S,$M,$H,$d,$m-1,$y-1900);
    my $this_cam_delta = get_matching_cam_delta($epoch) || $cam_delta;
    $epoch -= $this_cam_delta;
    my @l = localtime $epoch;
    ($S,$M,$H,$d,$m,$y) = @l;
    $y+=1900;
    $m++;

    my $iso_date = sprintf "%04d-%02d-%02dT%02d:%02d:%02d", $y,$m,$d,$H,$M,$S;
    my $iso_date2 = sprintf "%04d-%02d-%02dT%02d%02d%02d", $y,$m,$d,$H,$M,$S;

    if ($date_db) {
	my($key, $val) = ($iso_date2, "");
	my $st = $date_db->seq($key, $val, R_CURSOR);
	my $used;
	if ($st == 0) {
	    if (my($fy,$fm,$fd,$fH,$fM,$fS) = $key =~ m{^(\d+)-(\d+)-(\d+)T(\d{2})(\d{2})(\d{2})}) {
		my $got_epoch = timelocal($fS,$fM,$fH,$fd,$fm-1,$fy-1900);
		my $delta = abs($got_epoch - $epoch);
		my(@fields) = split / /, $val;
		$used = "next";

		# got previous
		$st = $date_db->seq($key, $val, R_PREV);
		if ($st == 0) {
		    if (my($py,$pm,$pd,$pH,$pM,$pS) = $key =~ m{^(\d+)-(\d+)-(\d+)T(\d{2})(\d{2})(\d{2})}) {
			my $got_prev_epoch = timelocal($pS,$pM,$pH,$pd,$pm-1,$py-1900);
			my $prev_delta = abs($got_prev_epoch - $epoch);
			if ($prev_delta < $delta) {
			    # prefer previous
			    (@fields) = split / /, $val;
			    $delta = $prev_delta;
			    $used = "prev";
			}
		    }
		}

		if ($delta <= $max_delta) {
		    my $ret = { Longitude => $fields[1],
				Latitude  => $fields[2],
				Delta    => $delta,
				Waypoint => undef, # !
				Date     => $iso_date,
				Used     => $used,
			      };
		    return $ret;
		}
	    }
	}
	warn "Can't find $iso_date2 in DB, use fallback...\n";
    }

    my $isodate1 = sprintf("%04d%02d%02d", $y,$m,$d);
    my $isodate2 = sprintf("%04d-%02d-%02d", $y,$m,$d);

    my @filenames = map {
	($gps_data_dir . "/" . $_,
	 $gps_data_dir . "/generated/" . $_, # This is the directory where generated tracks (e.g. originally from GPX) live
	)
    } ("$isodate1.trk", "$isodate2.trk");

    my $filename;
    for my $check_filename (@filenames) {
	warn "Try $check_filename for date $iso_date...\n"
	    if $v;
	if (-e $check_filename) {
	    $filename = $check_filename;
	    last;
	}
    }

    if (!$filename) {
	for my $check_filename (glob("$gps_data_dir/*$isodate1*.trk"),
				glob("$gps_data_dir/*$isodate1*.track*"),
				glob("$gps_data_dir/*$isodate2*.trk"),
				glob("$gps_data_dir/*$isodate2*.track*"),
			       ) {
	    warn "Try $check_filename (via globbing)...\n"
		if $v;
	    if (-e $check_filename) { # should never fail
		$filename = $check_filename;
		last;
	    }
	}
    }

    if ($filename) {
	my $gps = GPS::GpsmanData->new;
	$gps->load($filename);
	my $got_wpt;
	my $last_wpt;
	my $delta;
	for my $wpt (@{ $gps->Track }) {
	    my $wpt_epoch = $wpt->Comment_to_unixtime($gps);
	    if ($wpt_epoch > $epoch) {
		if ($last_wpt &&
		    abs($last_wpt->Comment_to_unixtime($gps) - $epoch) <
		    abs($wpt_epoch - $epoch)) {
		    $got_wpt = $last_wpt;
		} else {
		    $got_wpt = $wpt;
		}
		last;
	    }
	    $last_wpt = $wpt;
	}
	if (!$got_wpt) {
	    $got_wpt = $gps->Track->[-1];
	}
	$delta = abs($got_wpt->Comment_to_unixtime($gps) - $epoch);
	if ($got_wpt) {
	    return { Latitude  => $got_wpt->Latitude,
		     Longitude => $got_wpt->Longitude,
		     Delta  => $delta,
		     Waypoint  => $got_wpt,
		     Date      => $iso_date,
		   };
	}
    }
    undef;
}

if ($date_index_file) {
    $date_db = tie my %db, 'DB_File', $date_index_file, O_RDONLY, 0644, $DB_BTREE
	or die "Can't tie $date_index_file: $!";
    
}

my $ofh;
if (defined $out_file) {
    $out_file = realpath $out_file;
    open $ofh, ">", "$out_file.$$"
	or die "Cannot write to $out_file.$$: $!";
    select $ofh;
}

for my $file (@images) {
    if (-d $file) {
	require File::Find;
	$File::Find::name = $File::Find::name if 0; # cease -w
	$File::Find::prune = $File::Find::prune if 0; # cease -w
	my @files;
	File::Find::find(sub {
			     if ($_ eq '.xvpics' || $_ eq '.thumbs') {
				 $File::Find::prune = 1;
				 return;
			     }
			     if (-f $_ && -r $_) {
				 push @files, $File::Find::name;
			     }
			 }, $file);
	for my $file (@files) {
	    handle_file($file);
	}
    } else {
	handle_file($file);
    }
}
$current_info = "END";

if ($ofh) {
    close $ofh
	or die "While closing filehandle: $!";
    rename "$out_file.$$", $out_file
	or die "Can't rename $out_file.$$ to $out_file: $!";
    select STDOUT;
}

sub handle_file {
    my $file = shift;
    print STDERR "Handling $file...\n" if $v;
    $current_info = "Handling $file";
    my $ret = get_image_location($file);
    if (defined $ret) {
	my($lat, $long, $delta, $date) = @{$ret}{qw(Latitude Longitude Delta Date)};
	my($x, $y) = $Karte::Standard::obj->trim_accuracy
	    ($Karte::Polar::obj->map2standard($long, $lat));
	my $file_in_bbd;
	if ($relative_paths) {
	    if ($out_file) {
		$file_in_bbd = File::Spec->abs2rel(File::Spec->rel2abs($file), dirname($out_file));
	    } else {
		$file_in_bbd = $file;
	    }
	} else {
	    $file_in_bbd = File::Spec->rel2abs($file);
	}
	my $thumb_file = create_thumbnail($file);
	if ($relative_paths) {
	    if (defined $thumb_file) {
		$thumb_file = File::Spec->abs2rel(realpath($thumb_file),
						  (defined $out_file ? dirname($out_file) : ())
						 );
	    }
	}
	if (defined $thumb_file) {
	    my $delta_hm = s2hm($delta);
	    print qq{Image: "$file_in_bbd" ($date) (delta=$delta_hm) ($lat/$long)\tIMG:$thumb_file};
	    if ($anchor) {
		print qq{|ANCHOR:$anchor};
	    }
	    print qq{ $x,$y\n};
	}
    }
}

sub create_thumbnail {
    my $file = shift;
    $current_info = "Create thumbnail for $file";

    # Save your thumbnail
    my $dest;
    if (defined &md5_hex) {
	my($ext) = $file =~ /(\.[^\.]+)$/;
	$ext = "" if !defined $ext;
	$dest = $thumbnail_dir . "/" . md5_hex($file) . $ext;
    } else {
	$dest = $thumbnail_dir . "/" . basename($file);
    }

    return $dest if (-r $dest && !$recreate_thumbnails);

    warn "Create thumbnail for $file...\n" if $v;

    if ($converter eq 'Image::GD::Thumbnail') {
	return create_thumbnail_Image_GD_Thumbnail($file, $dest);
    } elsif ($converter eq 'ImageMagick') {
	return create_thumbnail_ImageMagick($file, $dest);
    } elsif ($converter eq 'ImageMagick+exiftool') {
	return create_thumbnail_ImageMagick_exiftool($file, $dest);
    } else {
	die "Unknown converter $converter";
    }
}

sub create_thumbnail_Image_GD_Thumbnail {
    my($file, $dest) = @_;
    my ($thumb,$x,$y);
    eval {
	open my $IN, $file or die "Could not open $file: $!";
	binmode $IN;
	my $srcImage = GD::Image->new($IN);
	close $IN;
	
	($thumb,$x,$y) = Image::GD::Thumbnail::create($srcImage,$thumbnail_size);
    };
    if ($@) {
	warn $@;
	return undef;
    } else {
	open my $OUT, ">", "$dest.$$" or die "Could not save $dest: $!";
	binmode $OUT;
	print $OUT $thumb->jpeg;
	close $OUT;
	rename "$dest.$$", $dest
	    or die "Cannot rename $dest.$$ to $dest: $!";
	return $dest;
    }
}

sub create_thumbnail_ImageMagick_exiftool {
    my($file, $dest) = @_;
    require File::Temp;
    my(undef,$smallfile) = File::Temp::tempfile(SUFFIX => "_geocode_images.jpg", UNLINK => 1);
    for my $cmd (["exiftool", "-ThumbnailImage", "-b", $file],
		 ["exiftool", "-PreviewImage",   "-b", $file],
		) {
	my @cmd = @$cmd;
	warn "@$cmd > $smallfile\n" if $v;
	open my $fh, "-|", @cmd
	    or die "Cannot execute @cmd: $!";
	open my $ofh, ">", $smallfile
	    or die "Cannot write to $smallfile: $!";
	local $/ = \8192;
	while(<$fh>) {
	    print $ofh $_;
	}
	close $ofh;
	close $fh;
	last if (!-z $smallfile);
    }
    if (-z $smallfile) {
	$smallfile = $file;
    }
    create_thumbnail_ImageMagick($smallfile, $dest);
}

sub create_thumbnail_ImageMagick {
    my($file, $dest) = @_;
    # -strip: remove EXIF from thumbnail, otherwise it's huge!
    my @cmd = ("convert", "-quality", 70, "-strip", "-resize", $thumbnail_size ."x". $thumbnail_size, $file, $dest);
    warn "@cmd\n" if $v;
    system @cmd;
    if ($? != 0 || -z $dest) {
	warn "@cmd failed: $?";
	return undef;
    } else {
	return $dest;
    }
}

sub get_cam_delta {
    my($clock_gps, $clock_camera) = @_;

    my($gps_H, $gps_M, $gps_S) = split /:/, $clock_gps;
    my($cam_H, $cam_M, $cam_S) = split /:/, $clock_camera;
    my $gps_seconds = $gps_H*60*60 + $gps_M*60 + ($gps_S||0);
    my $cam_seconds = $cam_H*60*60 + $cam_M*60 + ($cam_S||0);
    $cam_delta = $cam_seconds - $gps_seconds;
    
    $cam_delta;
}

sub get_matching_cam_delta {
    my($epoch) = @_;
    for my $def (@cam_delta_mapping) {
	my($from_epoch, $to_epoch, $this_cam_delta) = @$def;
	if ($from_epoch <= $epoch && $epoch <= $to_epoch) {
	    warn "Get cam delta=$this_cam_delta for $epoch...\n" if $debug;
	    return $this_cam_delta;
	}
    }
    warn "Found NO matching cam delta for $epoch...\n" if $debug;
    undef;
}

# REPO BEGIN
# REPO NAME is_in_path /home/e/eserte/work/srezic-repository 
# REPO MD5 81c0124cc2f424c6acc9713c27b9a484
sub is_in_path {
    my($prog) = @_;
    return $prog if (file_name_is_absolute($prog) and -f $prog and -x $prog);
    require Config;
    my $sep = $Config::Config{'path_sep'} || ':';
    foreach (split(/$sep/o, $ENV{PATH})) {
	if ($^O eq 'MSWin32') {
	    # maybe use $ENV{PATHEXT} like maybe_command in ExtUtils/MM_Win32.pm?
	    return "$_\\$prog"
		if (-x "$_\\$prog.bat" ||
		    -x "$_\\$prog.com" ||
		    -x "$_\\$prog.exe" ||
		    -x "$_\\$prog.cmd");
	} else {
	    return "$_/$prog" if (-x "$_/$prog" && !-d "$_/$prog");
	}
    }
    undef;
}
# REPO END

# REPO BEGIN
# REPO NAME file_name_is_absolute /home/e/eserte/work/srezic-repository 
# REPO MD5 89d0fdf16d11771f0f6e82c7d0ebf3a8
BEGIN {
    if (eval { require File::Spec; defined &File::Spec::file_name_is_absolute }) {
	*file_name_is_absolute = \&File::Spec::file_name_is_absolute;
    } else {
	*file_name_is_absolute = sub {
	    my $file = shift;
	    my $r;
	    if ($^O eq 'MSWin32') {
		$r = ($file =~ m;^([a-z]:(/|\\)|\\\\|//);i);
	    } else {
		$r = ($file =~ m|^/|);
	    }
	    $r;
	};
    }
}
# REPO END

__END__

=head1 NAME

geocode_images - geocode images against a gps track data base

=head1 SYNOPSIS

See L</EXAMPLES>

=head1 DESCRIPTION

With geocode_images it is possible to create a connection between exif
coded images and a database of GPS tracks. The connection is done
through the date.

For now, it is assumed that the GPS track database is just a directory
with GPSMAN track files, where filenames are named I<YYYYMMDD.trk> or
I<YYYY-MM-DD.trk>.

=head2 Adjusting clocks

For successful geocoding it is necessary to have synchronized clocks
in the GPS receiver and the camera. The GPS clock is very accurate,
but the camera clock usually is not. A nice technique is too make a
photo of the GPS device while displaying the time (including
seconds!), later determine the camera clock of this photo, and use
this for the -clock* options:

    geocode_images -clockgps HH:MM:SS -clockcamera HH:MM:SS ...

where the -clockgps value is what is visible on the photo and the
-clockcamera value is what is visible in the EXIF data of the photo.

It is also possible to maintain a database of such clock adjustments
in a file. This is just a text file with whitespace-separated fields,
either:

   ISO_date_time_from	ISO_date_time_to	gps_time	camera_time

or

   ISO_date	gps_time	camera_time

(ISO date time is here YYYYMMDDTHHMMSS, with possible separators, and
ISO date is YYYYMMDD, with possible separators).

The first field or first two fields denote the validity time of the
adjustment.

=head1 EXAMPLES

Assuming photos are located in files and subdirectories of the
directory ~/images and the generated bbd should go to /tmp:

    ~/src/bbbike/miscsrc/geocode_images -o /tmp/geocoded_images.bbd ~/images

Or using a "find" before:

    find ~/images/scans/Baltikum-02/baltics-bestof/ -name "*.jpg" -print0 | xargs -0 ~/src/bbbike/miscsrc/geocode_images -v -gpsdatadir ~/src/bbbike/misc/gps_data/polen_baltikum/ > /tmp/5.bbd

    cd ~/images/from_handy/Fotos/ && find . -name "*.jpg" -print0 | xargs -0 ~/src/bbbike/miscsrc/geocode_images > /tmp/1.bbd

Or put instructions in a makefile:

    geocode-rj1:
	mkdir -p rj-fotos/.xvpics
	$(HOME)/src/bbbike/miscsrc/geocode_images \
	    -gpsdatadir $(HOME)/src/bbbike/misc/gps_data/other \
	    -thumbnaildir rj-fotos/.xvpics \
	    -converter fast \
	    -clockgps 08:52:02 -clockcamera 08:49:43 \
	    -v -anchor nw -relativepaths \
	    rj-fotos/*.jpg > rj-fotos.bbd

B<-relativepaths> assumes that thumbnaildir, the specified photos and
the generated bbd file are relative to each other.

The B<-dateindex I</tmp/gpsdateindex.db>> option assumes that a GPS
index was build before with L<create_track_index.pl>.

=head1 HOWTO

To display geocoded thumbnails in bbbike:

=over

=item * Start bbbike

=item * Load the BBBikeViewImages plugin through "Plugin laden". The
plugin is located in the F<miscsrc> subdirectory of bbbike.

=item * Create a bbd file like explained in L</EXAMPLES>.

=item * Load the bbd file in bbbike: Zus‰tzlich zeichnen > Straﬂen-Layer zeichnen

=item * If necessary, then adjust the scrollregion (in the same menu)

=item * If the plugin was loaded and activated ("View Images mode"),
then it is possible to click on the thumbnails to get the larger
version

=back

=head1 TODO

 * There could be an -update switch
 * Instructions needed on how to create
   a bundle suitable for sharing with other people
 * GPX support

=head1 SEE ALSO

L<create_track_index.pl>

=cut
