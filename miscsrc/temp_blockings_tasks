#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2009,2011,2013,2016,2017 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use warnings;

sub usage (;$) {
    my $msg = shift;
    warn $msg, "\n" if $msg;
    die <<EOF;
usage: $0 task
EOF
}

my $task = shift
    or usage("Task is missing");

if ($task eq 'yml_to_permanent_bbd') {
    warn "WARNING: Please rename 'yml_to_permanent_bbd' to 'yml_to_recurring_bbd'.\n";
    $task = 'yml_to_recurring_bbd';
} elsif ($task eq 'yml_to_nonpermanent_bbd') {
    warn "WARNING: Please rename 'yml_to_nonpermanent_bbd' to 'yml_to_nonrecurring_bbd'.\n";
    $task = 'yml_to_nonrecurring_bbd';
}

if ($task eq 'pl_to_yml') {
    my $in_file = shift
	or usage("in file is missing");
    my $out_file = shift
	or usage("out file is missing");
    @ARGV and usage("extra args");

    _add_bbbike_inc();
    require BBBikeYAML;

    my $temp_blocking_records = _load_records($in_file);
    BBBikeYAML::DumpFile($out_file, $temp_blocking_records);

} elsif ($task eq 'cmp_pl_and_yml') {
    my $file_pl = shift
	or usage("pl file is missing");
    my $file_yml = shift
	or usage("yml file is missing");
    @ARGV and usage("extra args");

    require Data::Compare;
    require Data::Dumper;
    require File::Temp;

    _add_bbbike_inc();
    require BBBikeYAML;

    $file_pl = _make_abs_path($file_pl);

    use vars qw(@temp_blocking);
    local @temp_blocking;
    do $file_pl;
    die "Can't find \@temp_blocking array in $file_pl" if not @temp_blocking;
    my $y = BBBikeYAML::LoadFile($file_yml);

    no warnings 'once';
    local $Data::Dumper::Sortkeys = 1;
    if (not Data::Compare::Compare(\@temp_blocking, $y)) {
	my($tmp1fh,$tmp1file) = File::Temp::tempfile(SUFFIX => "_temp_blockings.pl") or die;
	my($tmp2fh,$tmp2file) = File::Temp::tempfile(SUFFIX => "_temp_blockings.yml") or die;
	print $tmp1fh Data::Dumper->new([\@temp_blocking],[])->Dump;
	print $tmp2fh Data::Dumper->new([$$y],[])->Dump;
	close $tmp1fh or die;
	close $tmp2fh or die;
	system("diff", "-u", $tmp1file, $tmp2file);
	exit 1;
    }

} elsif ($task eq 'yml_to_bbd') {
    my $infile = shift
	or usage "yml file is missing";
    @ARGV and usage "Extra args";

    yml_to_bbd($infile);

} elsif ($task eq 'yml_to_recurring_bbd') {
    my $infile = shift
	or usage "yml file is missing";
    @ARGV and usage "Extra args";

    yml_to_bbd($infile, filter => 'recurring');

} elsif ($task eq 'yml_to_nonrecurring_bbd') {
    my $infile = shift
	or usage "yml file is missing";
    @ARGV and usage "Extra args";

    yml_to_bbd($infile, filter => 'nonrecurring');

} elsif ($task eq 'check_recurrences') {
    require Getopt::Long;
    my $prewarn_days = 7;
    my $now;
    if (!Getopt::Long::GetOptions(
				  "prewarn-days=f" => \$prewarn_days,
				  "now=s" => \$now,
				 )) {
	die "usage: $0 $task [--prewarn-days=...] [--now=YYYY-MM-DDTHH:MM:SS] bbbike_temp_blockings.pl\n";
    }
    my $pl_file = shift
	or usage "pl file is missing";
    my $temp_blocking_records = _load_records($pl_file);
    check_recurrences($temp_blocking_records, prewarn_days => $prewarn_days, now => $now);
} elsif ($task eq 'check_data_islands') {
    require Getopt::Long;
    my $acceptable_distance = 1000; # visible area on my monitor at 1:6000 is approx. 2800x1300 meters, so 1000 is hopefully enough
    if (!Getopt::Long::GetOptions(
				  'acceptable-distance=i' => \$acceptable_distance,
				 )) {
	die "usage: $0 $task [--acceptable_distance=...] bbbike_temp_blockings.pl\n";
    }
    my $pl_file = shift
	or usage 'pl file is missing';
    my $temp_blocking_records = _load_records($pl_file);
    check_data_islands($temp_blocking_records, acceptable_distance => $acceptable_distance);
} else {
    usage("Task $task is unknown");
}

sub yml_to_bbd {
    my($infile, %args) = @_;
    my $filter_recurring    = $args{'filter'} && $args{'filter'} eq 'recurring';
    my $filter_nonrecurring = $args{'filter'} && $args{'filter'} eq 'nonrecurring';

    _add_bbbike_inc();
    require BBBikeYAML;

    my $x = BBBikeYAML::LoadFile($infile);
    my $done_header;
    my $id = -1;
    for my $rec (@$x) {
	$id++;
	my $d = $rec->{data}; # XXX no support for $rec->{file} --- is this intentional?
	next if not $d;
	next if $filter_recurring    && !($rec->{permanent} || $rec->{recurring});
	next if $filter_nonrecurring &&  ($rec->{permanent} || $rec->{recurring});
	if (!$done_header) {
	    print "#: source_file: $infile\n#:\n";
	    $done_header = 1;
	}
	print "# \n";
	print "#: id: $id vvv\n";
	if ($rec->{source_id}) {
	    my @source_ids = ref $rec->{source_id} eq 'ARRAY' ? @{ $rec->{source_id} } : $rec->{source_id};
	    for my $source_id (@source_ids) {
		print "#: by: $source_id\n";
	    }
	    my @real_source_ids = _filter_real_source_ids(@source_ids);
	    for my $source_id (@real_source_ids) {
		print "#: source_id: $source_id\n";
	    }
	}
	my $t = $rec->{text};
	$t =~ s{[\n\t]}{ }g;
	$d =~ s{^(?!\#)(.)}{
	    $t . (substr($1,0,1) eq "\t" ? "" : " ") . $1 # separate with space only if there's a non-empty name in the bbd line
	}gme;
	print $d;
	print "#: id ^^^\n";
    }
}

sub check_recurrences {
    my($temp_blocking_records, %args) = @_;

    my $prewarn_days = delete $args{prewarn_days};
    my $now = delete $args{now};
    die "Unhandled args: " . join(" ", %args) if %args;

    require DateTime;
    require DateTime::Event::Easter;
    require DateTime::Event::Recurrence;

    require Encode::Locale;

    my $now_dt;
    if ($now) {
	require DateTime::Format::ISO8601;
	$now_dt = DateTime::Format::ISO8601->parse_datetime($now);
    } else {
	$now_dt = DateTime->now;
    }

    my @candidates;
    my $id = -1;
    for my $record (@$temp_blocking_records) {
	$id++;
	my $set;
	for my $recurrence (@{ $record->{recurrences} || [] }) {
	    my($method, @method_args) = @$recurrence;
	    my $set;
	    if ($method eq 'easter') {
		$set = DateTime::Event::Easter->new(day => $method_args[0]);
	    } else {
		## does not work: start parameter seems to work only together with interval
		#my %method_args = @method_args;
		#if ($method_args{start}) {
		#    require DateTime::Format::ISO8601;
		#    $method_args{start} = DateTime::Format::ISO8601->parse_datetime($method_args{start});
		#}
		#$set = DateTime::Event::Recurrence->$method(%method_args);
		$set = DateTime::Event::Recurrence->$method(@method_args);
	    }
	    if ($set) {
		my $dt_last = DateTime->from_epoch(epoch => $record->{until});
		my $dt_next = $set->can('next') ? $set->next($dt_last) : $set->following($dt_last); # next for ::Recurrence, ->following for ::Easter
		if (!$dt_next) {
		    die "Cannot find next recurrence day for record '" . $record->{text} . "', id $id...";
		}
		my $this_prewarn_days = (
					 defined $record->{recurrence_prewarn_days} && $record->{recurrence_prewarn_days} < $prewarn_days
					 ? $record->{recurrence_prewarn_days}
					 : $prewarn_days
					);
		$dt_next = $dt_next->subtract(days => $this_prewarn_days);
		if ($dt_next <= $now_dt) {
		    push @candidates, { record => $record, id => $id, date => $dt_next };
		}
	    }
	}
    }

    if (@candidates) {
	require Text::Wrap;
	binmode STDOUT, ':encoding(console_out)';
	for my $candidate (sort { $a->{date} cmp $b->{date} } @candidates) {
	    my $text = $candidate->{record}->{text};
	    my $initial = sprintf("%6d: ", $candidate->{id});
	    print Text::Wrap::wrap($initial, " " x length($initial), "$candidate->{date} $text\n");
	}
	exit 1;
    } else {
	exit 0;
    }
}

sub check_data_islands {
    my($temp_blocking_records, %args) = @_;
    my $acceptable_distance = delete $args{acceptable_distance};
    die "Unhandled args: " . join(" ", %args) if %args;

    _add_bbbike_inc();
    require Strassen::Core;
    require Strassen::StrassenNetz;
    require Strassen::Check;
    require Strassen::Util;

    my $possible_errors = 0;
    for my $record (@$temp_blocking_records) {
	next if !$record->{data}; # XXX what about file?
	my $s = Strassen->new_from_data_string($record->{data});
	my $net = StrassenNetz->new($s);
	$net->make_net;
	my $islands = Strassen::Check::get_islands($net, shortcut => 0);
	next if (@$islands <= 1);
	@$islands = sort { scalar(keys %$b) <=> scalar(keys %$a) } @$islands;

	my $this_acceptable_distance = $record->{accept_multi_feature_distance} || $acceptable_distance;

    CHECK_ISLAND:
	for my $island_i (1 .. $#$islands) {
	    my $min_dist;
	    my @nearest_points;
	    for my $island1_point (keys %{ $islands->[0] }) {
		for my $island2_point (keys %{ $islands->[$island_i] }) {
		    my $dist = Strassen::Util::strecke_s($island1_point, $island2_point);
		    if ($dist <= $this_acceptable_distance) {
			next CHECK_ISLAND;
		    } elsif (!$min_dist || $dist < $min_dist) {
			$min_dist = $dist;
			@nearest_points = ($island1_point, $island2_point);
		    }
		}
	    }
	    warn "Found far-away data islands in record (distance $min_dist from largest island, acceptable is $this_acceptable_distance, nearest points are: @nearest_points)";
	    require Data::Dumper; print STDERR "Line " . __LINE__ . ", File: " . __FILE__ . "\n" . Data::Dumper->new([$record, $islands],[qw(need_to_check)])->Indent(1)->Useqq(1)->Sortkeys(1)->Terse(1)->Dump;
	    $possible_errors++;
	}
    }

    die "$possible_errors error(s) found" if $possible_errors;
}

sub _filter_real_source_ids {
    my(@source_ids) = @_;
    my @ret_source_ids;
    for my $source_id (@source_ids) {
	next if $source_id =~ m{^https?://};
	(my $ret_source_id = $source_id) =~ s{\s+.*}{};
	push @ret_source_ids, $ret_source_id;
    }
    @ret_source_ids;
}

sub _add_bbbike_inc {
    require lib;
    require FindBin;
    lib->import("$FindBin::RealBin/..", "$FindBin::RealBin/../lib");
}

sub _load_records {
    my $in_file = shift;
    $in_file = _make_abs_path($in_file);

    no warnings 'once';
    use vars qw(@temp_blocking);
    local @temp_blocking;
    do $in_file;
    die "Can't find \@temp_blocking array in $in_file" if not @temp_blocking;

    \@temp_blocking;
}

sub _make_abs_path {
    my $path = shift;
    require File::Spec;
    if (!File::Spec->file_name_is_absolute($path)) {
	$path = File::Spec->rel2abs($path);
    }
    $path;
}

__END__
