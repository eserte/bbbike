#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: osm2bbd,v 1.31 2008/08/11 19:34:39 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2008 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use lib "$FindBin::RealBin/..";

use Data::Dumper;
use Getopt::Long;
use IO::File;
use XML::LibXML;

sub epoch2isodate (;$);
sub touch ($);

my $o;
my $f;
my $v;
my $encoding = "utf-8";
my $debug;

my $map;
my $center;

my $parsefor;

sub usage () {
    <<EOF;
usage: $0 [-v] [-f] [-encoding enc] [-map bbbike [-center lon,lat]] -o directory osmfile ...

-v:              Show parser progress
-f:              Force overwriting existing output directory
-enc ...:        Specify different encoding, standard is utf-8
-map bbbike:     Use BBBike coordinates instead of WGS 84 coordinates in the
                 output. Recommended until BBBike is able to fully handle
                 WGS 84 coordinates.
-center lon,lat: If -map bbbike is used, then specify the 0,0 point. Defaults
                 to standard Berlin setting.
-o directory:    A not-existing directory to output the bbd files.
-parsefor ...:   Parse only for the given key=value pair,
                 key as string and val as regexp
osmfile ...:     Files downloaded by downloadosm,
                 or directory containing .osm files
EOF
}

GetOptions("o=s" => \$o,
	   "f" => \$f,
	   "v" => \$v,
	   "debug" => \$debug,
	   "map=s" => \$map,
	   "center=s" => \$center,
	   "encoding=s" => \$encoding,
	   "parsefor=s" => \$parsefor,
	  )
    or die usage;

my @osm_files = @ARGV;
if (!@osm_files) {
    die <<EOF . "\n" . usage;
Please specify one or more osm files. To download an osm file, you can use
the script downloadosm (usually to be found in the same directory as this
script) or raw wget, for example

  wget -O filename.osm http://www.openstreetmap.org/api/0.5/map?bbox=x0,y0,x1,y1

Note that the bbox must not be too large, otherwise you get a 400 bad request
error.
EOF
}

my($parsefor_key, $parsefor_val);
if ($parsefor) {
    if (!(($parsefor_key, $parsefor_val) = $parsefor =~ m{^(.*)=(.*)$})) {
	die "-parsefor value <$parsefor> must be in the form key=val";
    }
    $parsefor_val = qr{$parsefor_val};
}

if (!$parsefor) {
    if (!$o) {
	die "Please specify (non-existent) output directory with -o option.\n" . usage;
    }
    if (!$f && -e $o) {
	die "Output directory <$o> must not exist (or specify -f to force overwrite).\n";
    }
}

my $p = XML::LibXML->new;

my %unhandled;
my %out;

my $do_amenity = sub {
    my($node, $amenity) = @_;
    my @or;
    my $F = $node->tagName eq 'way' ? "F:" : ""; # area or not?
    if ($amenity eq 'place_of_worship') {
	my $religion = $node->findvalue('./tag[@k="religion"]/@v');
	if (!$religion || $religion eq 'christian') {
	    push @or, ["sehenswuerdigkeit", $F."SW|IMG:church"];
	} elsif ($religion eq 'jewish') {
	    push @or, ["sehenswuerdigkeit", $F."SW|IMG:synagogue"];
	} elsif ($religion eq 'muslim') {
	    push @or, ["sehenswuerdigkeit", $F."SW|IMG:mosque"];
	} else {
	    $unhandled{"amenity-religion-$religion"}++;
	}
    } elsif ($amenity eq 'museum') {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:museum"];
    } elsif ($amenity eq 'hospital') {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:hospital"];
    } elsif ($amenity =~ m{^theat(?:er|re)$}) {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:theater"];
    } elsif ($amenity =~ m{^(shopping|shopping_centre)$}) {
	push @or, ["sehenswuerdigkeit", $F."Shop"];
    } elsif ($amenity =~ m{^(arts_center|courthouse|library|police|post_office|public_building|townhall|university|embassy|prison)$}) {
	push @or, ["sehenswuerdigkeit", $F."SW"];
    } elsif ($amenity =~ m{^(biergarten|cafe|cafeteria|pub|bar)$}) {
	push @or, ["kneipen", $F."X"];
    } elsif ($amenity =~ m{^(fast_food|restaurant)$}) {
	push @or, ["restaurants", $F."X"];
    } elsif ($amenity eq 'cinema') {
	push @or, ["kinos", $F."X"];
    } else {
	$unhandled{"amenity-$amenity"}++;
    }
    @or;
};

my $do_historic = sub {
    my($node, $historic) = @_;
    my @or;
    my $F = $node->tagName eq 'way' ? "F:" : ""; # area or not?
    if ($historic eq 'monument') {
	push @or, ["sehenswuerdigkeit", $F."SW|IMG:monument"];
    } elsif ($historic =~ m{^(castle|memorial|archaeological_site|ruins)$}) {
	push @or, ["sehenswuerdigkeit", $F."SW"];
    } else {
	$unhandled{"historic-$historic"}++;
    }
    @or;
};

my $do_unhandled = sub {
    my($node, $name_ref) = @_;

    for my $tag ($node->findnodes('./tag')) {
	my $key = $tag->getAttribute('k');
	next if $key =~ m{^(
			    name
			  | created_by
			  | source
			  | url
			 )$}x;
	my $val = $tag->getAttribute('v');
	if ($$name_ref) { $$name_ref .= "; " }
	$$name_ref .= "$key:$val";
    }
};

my $conv = sub {
    my($lon,$lat) = @_;
    "$lon,$lat";
};
if ($map) {
    if ($map ne 'bbbike') {
	die "Only -map bbbike is supported.\n";
    }
    require Karte::Polar;
    require Karte::Standard;

    my($dx,$dy) = (0,0);
    if ($center) {
	my($c_lon,$c_lat) = split /,/, $center;
	($dx,$dy) = $Karte::Standard::obj->trim_accuracy($Karte::Polar::obj->map2standard($c_lon,$c_lat));
    }

    $conv = sub {
	my($lon,$lat) = @_;
	my($x,$y) = $Karte::Standard::obj->trim_accuracy($Karte::Polar::obj->map2standard($lon,$lat));
	($x-$dx).",".($y-$dy);
    };
}

{
    # expand directories
    # XXX Should be really a recursive function, probably
    my @new_osm_files;
    for my $osm_file (@osm_files) {
	if (-d $osm_file) {
	    push @new_osm_files, grep { -f $_ && -s $_ } glob($osm_file . "/*.osm"); # XXX argh, grep duplicates functionality, see "recursive" suggestion above
	} elsif (-z $osm_file) {
	    # May happen while loading data, so ignore this
	    warn "Ignore empty file <$osm_file>...\n";
	} else {
	    push @new_osm_files, $osm_file;
	}
    }
    @osm_files = @new_osm_files;
}

my $tp;
eval {
    die "No terminal" if !is_interactive();
    require Time::Progress;
    $tp = Time::Progress->new;
    $tp->attr(min => 0, max => 2 * $#osm_files + 1);
    $tp->restart;
};

######################################################################
# NODES
my %node2ll;
my $osm_file_i = 0;
for my $osm_file (@osm_files) {
    if ($v) {
	if ($tp) {
	    print STDERR $tp->report("\rdone %p elapsed: %L (%l sec), ETA %E (%e sec)", $osm_file_i++);
	} else {
	    warn "Parse $osm_file for nodes...\n";
	}
    }
    my $root = $p->parse_file($osm_file)->documentElement;
    for my $node ($root->findnodes("/osm/node")) {
	my $id = $node->getAttribute('id');
	next if exists $node2ll{$id};
	my $lat = $node->getAttribute('lat');
	my $lon = $node->getAttribute('lon');
	$node2ll{$id} = $conv->($lon,$lat);

	my @or;

	my $name = "";
	my $railway_cat;
	my $highway_cat;
	my $amenity;
	my $historic;
	my $place;
	my $url;

	for my $tag ($node->findnodes("./tag")) {
	    my $k = $tag->getAttribute('k');
	    my $v = $tag->getAttribute('v');
	    if    ($k eq 'name')        { $name        = $v }
	    elsif ($k eq 'created_by')  {                    }
	    elsif ($k eq 'source')      {                    }
	    elsif ($k eq 'railway')     { $railway_cat = $v }
	    elsif ($k eq 'highway')     { $highway_cat = $v }
	    elsif ($k eq 'amenity')     { $amenity     = $v }
	    elsif ($k eq 'historic')    { $historic    = $v }
	    elsif ($k eq 'place')       { $place       = $v }
	    elsif ($k eq 'url')         { $url         = $v }
	}

	if ($url) {
	    $name .= ($name ? " " : "") . $url;
	}

	if (defined $parsefor_key) {
	    my $found_val = $node->findvalue('./tag[@k="' . $parsefor_key . '"]/@v');
	    if (defined $found_val && $found_val =~ $parsefor_val) {
		push @or, ["-", $found_val];
	    }
	} elsif ($railway_cat) {
	    if ($railway_cat eq 'station' ||
		$railway_cat eq 'halt') {
		if ($name =~ s{^U\s+}{}) {
		    push @or, ["ubahnhof", "UA"]; # note: not zones; XXX how to distinguish U, S and Regionalbahn correctly???
		} elsif ($name =~ s{^S\s+}{}) {
		    push @or, ["sbahnhof", "SA"]; # - " -
		} else {
		    push @or, ["rbahnhof", "RA"]; # - " -
		}
		# fix name, remove "Bahnhof":
		if ($name) {
		    $name =~ s{^(?:Bahnhof|Bhf\.?)\s+(.+)}{$1};
		}
	    } elsif ($railway_cat =~ m{^(crossing|level_crossing)$}) {
		push @or, ["ampeln", "B"];
	    } else {
		$unhandled{"node-railway=$railway_cat"}++;
	    }
	} elsif ($highway_cat) {
	    if ($highway_cat eq 'traffic_signals') {
		push @or, ["ampeln", "X"];
	    } else {
		$unhandled{"node-highway=$highway_cat"}++;
	    }
	} elsif ($place) {
	    my $population = $node->findvalue('./tag[@k="population"]/@v');
	    if (!$population) {
		$population = $node->findvalue('./tag[@k="openGeoDB:population"]/@v');
	    }
	    if ($population) {
		my $cat;
		if ($population >= 200000) {
		    $cat = 6;
		} elsif ($population >= 50000) {
		    $cat = 5;
		} elsif ($population >= 20000) {
		    $cat = 4;
		} elsif ($population >= 5000) {
		    $cat = 3;
		} elsif ($population >= 2000) {
		    $cat = 2;
		} elsif ($place eq 'hamlet') {
		    $cat = 0;
		} else {
		    $cat = 1;
		}
		push @or, ["orte", $cat];
	    } else {
		if ($place eq 'hamlet' || $place eq 'suburb') {
		    push @or, ["orte", 0];
		} elsif ($place eq 'village') {
		    push @or, ["orte", 1];
		} elsif ($place eq 'town') {
		    push @or, ["orte", 3];
		} elsif ($place eq 'city') {
		    push @or, ["orte", 5];
		} else {
		    $unhandled{"node-place=$place"}++;
		}
	    }
	} elsif ($amenity) {
	    push @or, $do_amenity->($node, $amenity);
	} elsif ($historic) {
	    push @or, $do_historic->($node, $historic);
	}

	if (!@or) {
	    $do_unhandled->($node, \$name);
	    if ($name ne "") {
		push @or, ["_unhandled", "X"];
	    }
	}

	for my $or (@or) {
	    my($out_file, $cat) = @$or;
	    push @{$out{$out_file}}, [$name, [$node2ll{$id}], $cat];
	}
    }
}

######################################################################
# WAYS
my %seenway;
for my $osm_file (@osm_files) {
    if ($v) {
	if ($tp) {
	    print STDERR $tp->report("\rdone %p elapsed: %L (%l sec), ETA %E (%e sec)", $osm_file_i++);
	} else {
	    warn "Parse $osm_file for ways...\n";
	}
    }
    my $root = $p->parse_file($osm_file)->documentElement;
    for my $way ($root->findnodes('/osm/way[@visible="true"]')) {
	my $id = $way->getAttribute('id');
	next if exists $seenway{$id};
	$seenway{$id} = 1;

	my $is_area;
	my @or;

	my @nodes = map { $_->textContent } $way->findnodes('./nd/@ref');

	my $name = "";
	my $url;
	my $highway_cat;
	my $waterway_cat;
	my $railway_cat;
	my $boundary;
	my $admin_level;
	my $natural;
	my $oneway;
	my $sport;
	my $leisure;
	my $cycleway;
	my $landuse;
	my $route;
	my $amenity;
	my $historic;
	my $place;
	my $tunnel;
	my $bridge;
	my $building;
	my $motorroad;

	for my $tag ($way->findnodes("./tag")) {
	    my $k = $tag->getAttribute('k');
	    my $v = $tag->getAttribute('v');
	    if    ($k eq 'name')         { $name         = $v }
	    elsif ($k eq 'created_by')   {                    }
	    elsif ($k eq 'source')       {                    }
	    elsif ($k eq 'url')          { $url          = $v }
	    elsif ($k eq 'highway')      { $highway_cat  = $v }
	    elsif ($k eq 'waterway')     { $waterway_cat = $v }
	    elsif ($k eq 'railway')      { $railway_cat  = $v }
	    elsif ($k eq 'boundary')     { $boundary     = $v }
	    elsif ($k eq 'admin_level')  { $admin_level  = $v }
	    elsif ($k eq 'natural')      { $natural      = $v }
	    elsif ($k eq 'oneway')       { $oneway       = $v }
	    elsif ($k eq 'sport')        { $sport        = $v }
	    elsif ($k eq 'leisure')      { $leisure      = $v }
	    elsif ($k eq 'cycleway')     { $cycleway     = $v }
	    elsif ($k eq 'landuse')      { $landuse      = $v }
	    elsif ($k eq 'route')        { $route        = $v }
	    elsif ($k eq 'amenity')      { $amenity      = $v }
	    elsif ($k eq 'historic')     { $historic     = $v }
	    elsif ($k eq 'place')        { $place        = $v }
	    elsif ($k eq 'tunnel')       { $tunnel       = $v }
	    elsif ($k eq 'bridge')       { $bridge       = $v }
	    elsif ($k eq 'building')     { $building     = $v }
	    elsif ($k eq 'motorroad')    { $motorroad    = $v }
	}

	if ($url) {
	    $name .= ($name ? " " : "") . $url;
	}
	if ($debug) {
	    $name .= "; id=$id";
	}

	my $do_cycleway = sub {
	    my @or;
	    if      ($cycleway eq 'lane') {
		push @or, ["radwege_exact", "RW4"];
	    } elsif ($cycleway eq 'track') {
		push @or, ["radwege_exact", "RW1"];
	    } elsif ($cycleway eq 'opposite') {
		push @or, ["radwege_exact", "RW9"];
	    } else {
		$unhandled{"cycleway-$cycleway"}++;
	    }
	    @or;
	};

	if ($highway_cat) {
	    my $is_motorway = 0;
	    my $is_motorroad = $motorroad and $motorroad eq 'yes' ? 1 : 0; # Kraftfahrzeugstraße

	    my $addcat = "";
	    if ($tunnel && $tunnel eq 'yes') {
		$addcat .= "::Tu";
	    } elsif ($bridge && $bridge eq 'yes') {
		$addcat .= "::Br";
	    }

	    if      ($highway_cat =~ m{^(motorway|motorway_link|trunk|trunk_link)$} || $is_motorroad) {
		push @or, ["strassen_bab", "BAB".$addcat];
		$is_motorway = 1;
	    } elsif ($highway_cat =~ m{^(primary|primary_link|secondary)$}) {
		push @or, ["strassen", "HH".$addcat];
	    } elsif ($highway_cat eq 'tertiary') {
		push @or, ["strassen", "H".$addcat];
	    } elsif ($highway_cat =~ m{^(residential|unclassified|service|minor)$}) {
		push @or, ["strassen", "N".$addcat];
	    } elsif ($highway_cat eq 'cycleway') {
		push @or, ["strassen", "NN".$addcat];
	    CYCLEWAY_KEY: {
		    if ($cycleway) {
			my @sub_or = $do_cycleway->();
			if (@sub_or) {
			    push @or, @sub_or;
			    last CYCLEWAY_KEY;
			}
		    }
		    # fallback
		    push @or, ["radwege_exact", "RW1"];
		}
	    } elsif ($highway_cat eq 'unsurfaced') {
		push @or, ["strassen", "N".$addcat];
		push @or, ["qualitaet_s", "Q2", name => ($name ? "$name: " : "") . "unbefestigte Straße"];
	    } elsif ($highway_cat eq 'track') {
		push @or, ["strassen", "NN".$addcat];
		push @or, ["qualitaet_s", "Q2", name => ($name ? "$name: " : "") . "Pfad"];
	    } elsif ($highway_cat eq 'footway') {
		push @or, ["strassen", "NN".$addcat];
		push @or, ["handicap_s", "q1", name => ($name ? "$name: " : "") . "Fußweg"];
	    } elsif ($highway_cat eq 'pedestrian') {
		push @or, ["strassen", "NN".$addcat];
		push @or, ["handicap_s", "q4", name => ($name ? "$name: " : "") . "Fußgängerzone"];
	    } elsif ($highway_cat eq 'living_street') {
		push @or, ["strassen", "N".$addcat];
		push @or, ["radwege_exact", "RW6;RW6", name => ($name ? "$name: " : "") . "verkehrsberuhigter Bereich"];
	    } elsif ($highway_cat eq 'construction') {
		my $construction = $way->findvalue('./tag[@k="construction"]/@v'); # seen in Berlin, strange one
		if ($construction && $construction eq 'motorway') {
		    push @or, ["strassen_bab", "BAB::inwork"];
		} else {
		    $unhandled{"highway=$highway_cat+construction=$construction"}++;
		}
	    } elsif ($highway_cat eq 'steps') {
		push @or, ["strassen", "NN".$addcat];
		push @or, ["gesperrt", "0:30", name => "Treppe"]; # XXX really should be only one point; lost time is guessed, maybe determine from length of feature? XXX
	    } else {
		$unhandled{"highway=$highway_cat"}++;
	    }
	    if ($oneway && !$is_motorway) {
		if ($oneway =~ m{^(yes|true)$}) {
		    push @or, ["gesperrt", "1", reversed => 1];
		} else {
		    $unhandled{"oneway=$oneway"}++;
		}
	    }

	    my $rcn_ref = $way->findvalue('./tag[@k="rcn_ref"]/@v');
	    my $lcn_ref = $way->findvalue('./tag[@k="lcn_ref"]/@v');
	    if ($rcn_ref) {
		push @or, ["comments_route", "CS", name => $rcn_ref];
	    }
	    if ($lcn_ref) {
		push @or, ["comments_route", "CS", name => $lcn_ref];
	    }

	} elsif ($waterway_cat) {
	    if      ($waterway_cat eq 'riverbank') {
		# only if it's closed
		if ($nodes[0] eq $nodes[-1]) {
		    push @or, ["wasserstrassen", "F:W"];
		} else {
		    warn "Found unclosed riverbank, sorry cannot use it...\n";
		}
	    } elsif ($waterway_cat eq 'canal') {
		push @or, ["wasserstrassen", "W"];
	    } elsif ($waterway_cat eq 'river') {
		push @or, ["wasserstrassen", "W1"];
	    } elsif ($waterway_cat eq 'stream') {
		push @or, ["wasserstrassen", "W2"];
	    } else {
		$unhandled{"waterway=$waterway_cat"}++;
	    }
	} elsif ($railway_cat) {
	    if      ($railway_cat eq 'subway') {
		push @or, ["ubahn", "U"]; # no zones
	    } elsif ($railway_cat eq 'light_rail') {
		push @or, ["sbahn", "S"]; # no zones
	    } elsif ($railway_cat eq 'rail') {
		push @or, ["rbahn", "R"];
	    } elsif ($railway_cat eq 'preserved') {
		# ignore
	    } elsif ($railway_cat eq 'service') {
		push @or, ["rbahn", "RG"];
	    } elsif ($railway_cat =~ m{^(abandoned|disused)$}) {
		push @or, ["rbahn", "R0"];
	    } elsif ($railway_cat =~ m{^(construction)$}) {
		push @or, ["rbahn", "RBau"];
	    } elsif ($railway_cat =~ m{^(narrow_gauge)$}) { # z.B. Parkeisenbahnen
		push @or, ["rbahn", "RP"];
	    } elsif ($railway_cat =~ m{\btram\b}) {
		push @or, ["comments_tram", "CS"];
	    } else {
		$unhandled{"railway=$railway_cat"}++;
	    }
	} elsif ($natural) {
	    if      ($natural eq 'water') {
		push @or, ["wasserstrassen", "F:W"];
	    } elsif ($natural eq 'wood') {
		push @or, ["flaechen", "F:Forest"];
	    } elsif ($natural eq 'land') {
		my $island = $way->findvalue('./tag[@k="island"]/@v'); # seen in Zuerich
		my $layer = $way->findvalue('./tag[@k="layer"]/@v'); # seen in Berlin
		if (($place && $place eq 'island') ||
		    ($island && $island =~ m{^(yes|true)$}) ||
		    (defined $layer && $layer ne "" && $layer == 1)
		   ) {
		    push @or, ["wasserstrassen", "F:I"];
		}
	    } else {
		$unhandled{"natural=$natural"}++;
	    }
	} elsif ($boundary) { # Sometimes there's boundary=administrative and natural=coastline at the same time. Currently I prefer coastline over boundary (see the Usedom data). But maybe I should render both? Think of it! XXX
	    if      ($boundary eq 'administrative') {
		if ($admin_level == 8) {
		    push @or, ["berlin_ortsteile", "Z"];
		} elsif ($admin_level == 2) {
		    push @or, ["deutschland", "Z"];
		} else {
		    $unhandled{"boundary=administrative,admin_level=$admin_level"}++;
		}
	    } else {
		$unhandled{"boundary=$boundary"}++;
	    }   
	} elsif ($place) {
	    if      ($place eq 'airport') {
		push @or, ["flaechen", "F:Ae"];
	    } else {
		$unhandled{"place=$place"}++;
	    }
	} elsif ($sport) {
	    if      ($sport =~ m{^(soccer|athletics)$}) {
		push @or, ["flaechen", "F:Sport"];
	    } else {
		$unhandled{"sport=$sport"}++;
	    }
	} elsif ($leisure) {
	    if      ($leisure eq 'park') {
		push @or, ["flaechen", "F:P"];
	    } elsif ($leisure eq 'stadium') {
		push @or, ["flaechen", "F:Sport"];
	    } elsif ($leisure eq 'cemetery') { # see below: landuse=cemetery
		push @or, ["flaechen", "F:Cemetery"];
	    } else {
		$unhandled{"leisure=$leisure"}++;
	    }
	} elsif ($cycleway) {
	    push @or, $do_cycleway->();
	} elsif ($landuse) {
	    if      ($landuse eq 'cemetery') {
		push @or, ["flaechen", "F:Cemetery"];
	    } elsif ($landuse eq 'industrial') {
		push @or, ["flaechen", "F:Industrial"];
	    } elsif ($landuse eq 'allotments') {
		push @or, ["flaechen", "F:Orchard"];
	    } elsif ($landuse eq 'forest') { # see above: natural=wood
		push @or, ["flaechen", "F:Forest"];
	    #XXX ja? nein? } elsif ($landuse eq 'water') { push @or, ["wasserstrassen", "F:W"];
	    } elsif ($landuse eq 'residential') {
		push @or, ["_building", "F:#d0d0d0"];
	    } else {
		$unhandled{"landuse=$landuse"}++;
	    }
	} elsif ($route) {
	    if      ($route eq 'ferry') {
	    TRY_FERRY: {
		    my @comments;
		    my $day_on = $way->findvalue('./tag[@k="day on"]/@v');
		    my $day_off = $way->findvalue('./tag[@k="day off"]/@v');
		    my $bicycle = $way->findvalue('./tag[@k="bicycle"]/@v');
		    if ($day_on && $day_off) {
			push @comments, "$day_on - $day_off";
		    }
		    if ($bicycle && $bicycle !~ m{^(yes|true)$}) {
			if ($bicycle =~ m{^(no|false)$}) {
			    last TRY_FERRY;
			}
			push @comments, "bicycle=$bicycle";
		    }
		    my $comments = join("; ", @comments);
		    push @or, ["faehren", "Q"];
		    if ($comments) {
			push @or, ["comments_ferry", "CS", name => $comments];
		    }
		}
	    } else {
		$unhandled{"route=$route"}++;
	    }
	} elsif ($amenity) {
	    push @or, $do_amenity->($way, $amenity);
	} elsif ($historic) {
	    push @or, $do_historic->($way, $historic);
	} elsif ($building) {
	    if ($building eq 'yes') {
		push @or, ["_building", "F:#cccccc"];
	    }
	}

	if (!@or) {
	    $do_unhandled->($way, \$name);
	    if ($name ne "") {
		push @or, ["_unhandled", "X"];
	    }
	}

	for my $or (@or) {
	    my($out_file, $cat, %args) = @$or;

	    my $name = $name;
	    my @nodes = @nodes;
	    if ($args{reversed}) {
		@nodes = reverse @nodes;
	    }
	    if ($args{name}) {
		$name = $args{name};
	    }
	    push @{$out{$out_file}}, [$name, [map { $node2ll{$_} } @nodes], $cat];
	}
    }
}

######################################################################
# OUTPUT
if ($parsefor) {
    output_data(\*STDOUT, $out{"-"});
} else {
    if (!mkdir $o) {
	die "Cannot create output directory <$o>: $!" if !$f;
    }
    chdir $o
	or die "Cannot chdir to $o: $!";
    while(my($filename,$data) = each %out) {
	print STDERR "$filename... ";
	open my $ofh, ">:encoding($encoding)", "$filename~"
	    or die "Can't write to file <$filename~> in directory <$o>: $!";
	output_data($ofh, $data);
	close $ofh
	    or die "Error while closing: $!";
	rename "$filename~", $filename
	    or die "Can't rename $filename~ to $filename: $!";
	print STDERR "\n";
    }

    # required files (dummy files, bbbike like to have these):
    for my $file (qw(gesperrt wasserumland wasserumland2 hoehe
		     orte orte2 qualitaet_l handicap_l
		     berlin deutschland orte_city
		     landstrassen landstrassen2
		    )) {
	touch $file;
    }
    for (qw(cyclepath misc path route tram kfzverkehr scenic)) {
	touch "comments_$_";
    }
    if (!-d "temp_blockings") {
	mkdir "temp_blockings";
    }
    touch "temp_blockings/bbbike-temp-blockings.pl";
}

if (%unhandled) {
    print "Unhandled categories:\n";
    local $Data::Dumper::Sortkeys = 1;
    print Dumper (\%unhandled);
}

sub output_data {
    my($ofh, $data) = @_;
    print $ofh <<EOF;
#: #: -*- coding: $encoding -*-
EOF
    if ($encoding ne 'iso-8859-1') {
	print $ofh <<EOF;
#:encoding: $encoding
EOF
    }
    if (!$map) {
	print $ofh <<EOF;
#:map: polar
EOF
    } elsif ($map ne 'bbbike') {
	print $ofh <<EOF;
#:map: $map
EOF
    }
my $isodate = epoch2isodate;
print $ofh <<EOF;
#:date: $isodate
#:
# Converted from openstreetmap data using $0
# DO NOT EDIT THIS FILE! Edit the original openstreetmap data!
#
EOF
    for my $rec (@$data) {
	my($name, $coords, $cat) = @$rec;
	print $ofh "$name\t$cat " . join(" ", @$coords) . "\n";
    }
}

sub touch ($) {
    my $file = shift;
    sysopen my $fh, $file, O_WRONLY|O_CREAT|O_NONBLOCK|O_NOCTTY
	or die "Can't create $file: $!";
    close $fh
	or die "Can't close $file: $!";
}

# REPO BEGIN
# REPO NAME epoch2isodate /home/e/eserte/work/srezic-repository 
# REPO MD5 a728acec57691739e2273d6c4836ecc1

sub epoch2isodate (;$) {
    my $time = shift || time;
    my @l = localtime $time;
    sprintf("%04d%02d%02d%02d%02d%02d",
	    $l[5]+1900, $l[4]+1, $l[3],
	    $l[2],      $l[1],   $l[0]);
}
# REPO END

# REPO BEGIN
# REPO NAME is_interactive /home/e/eserte/work/srezic-repository 
# REPO MD5 87e9e2500fbe4a3ffe5f977de8513d47
sub is_interactive {
    if ($^O eq 'MSWin32' || !eval { require POSIX; 1 }) {
	# fallback
	return -t STDIN && -t STDOUT;
    }

    # from perlfaq8
    open(TTY, "/dev/tty") or die $!;
    my $tpgrp = POSIX::tcgetpgrp(fileno(*TTY));
    my $pgrp = getpgrp();
    if ($tpgrp == $pgrp) {
	1;
    } else {
	0;
    }
}
# REPO END

__END__

=head1 NAME

osm2bbd - convert OpenStreetMap data for BBBike

=head1 HOWTO

Create a directory where to download OSM data. It's best to use an
empty directory. Convention: I use
C<misc/download/osm/I<region_name>> as a path name. For Berlin, this
would be:

    cd /path/to/bbbike
    mkdir -p misc/download/osm/berlin

Use L<downloadosm> to download the OSM data. Decide first on the
bounding box to download (see also hints below). To load all of
Berlin, use

    ./miscsrc/downloadosm -o misc/download/osm/berlin 13.010982 52.337651 13.761388 52.675354

With a standard DSL connection, this last about 1:30 hours, totalling
220 MB of data (as of July 2008).

Now convert the OSM data into a BBBike-readable format. This should
take 5 minutes or so (Athlon64, i386-freebsd) for the above dataset.
Decide on the destination directory. Convention: I use
C<data_I<region_name>_osm_bbbike>. Note: this directory should not
exist. For Berlin, this would be:

    ./miscsrc/osm2bbd -v -o data_berlin_osm_bbbike/ misc/download/osm/berlin

Finally call bbbike with the C<-datadir> option:

    ./bbbike -datadir data_berlin_osm_bbbike

=head2 HINTS

To get the bbox of a bbd file, use:

    perl -l -MKarte::Standard -MKarte::Polar -MStrassen -e '$s=Strassen->new("data/strassen"); ($x1,$y1,$x2,$y2) = $s->bbox; print join(",", $Karte::Polar::obj->standard2map($x1,$y1),$Karte::Polar::obj->standard2map($x2,$y2))'


=head1 EXAMPLES

To convert data for the San Francisco area:

=over

=item 1. download geo data for San Francisco/SFO from opensteetmaps.org

    ./miscsrc/downloadosm -o ../sfbike/sfo -- -122.527 37.594 -122.351 37.811

=item 2. convert *.osm files to bbbike data

    ./miscsrc/osm2bbd -f -map bbbike -center -122.598,37.6829 -o data-sfo -d ../sfbike/sfo

=item 3. start sfbike, english version

    env LANG=en_US.UTF-8 perl ./bbbike -datadir data-sfo

=back

=head1 BUGS

You should probably specify the -center option, otherwise the map
apparently won't show up in bbbike (it is there, but not in the active
visible region). (There could be an -autocenter option calculated from
the bounding box of the map data)

=cut

